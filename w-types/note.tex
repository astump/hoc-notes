\documentclass{article}

\usepackage{amsmath,amssymb,amsthm}
\usepackage{url}
\usepackage{hyperref}
\usepackage{proof}
\usepackage{stmaryrd}
%\usepackage{MnSymbol}
\usepackage{parskip}
\usepackage{fullpage}
\usepackage{mathpartir}
\usepackage{subcaption}
\usepackage{float}


\begin{document}

\include{definitions}

\title{Proposal for Basing Bend2 on W-Types}

\author{Aaron Stump}

\maketitle

\section{Bend2's Philosophy}

Bend2 is based on a novel proposal (as far as I know) for how to
design a type theory, which is a form of pure functional programming
language that can also be viewed as a logic.  To be sound as a logic,
the language should not allow one to prove False.

There are two current traditions for devising type theories, that
should be mentioned for comparison with Bend2's approach:

\begin{enumerate}
\item \textbf{Church-style} type theory builds up a notion of typed
  terms (programs), where the types are inherent to those terms.  By a
  difficult argument, one shows that all well-typed programs
  terminate.  So the type system is enforcing termination, in addition
  to other properties usually enforced by static typing.  From
  termination, it is then easy to argue that the system is logically
  sound.  This is because it is relatively easy to show that values,
  which are the final results of computation, cannot have type False.

\item \textbf{Curry-style} type theory starts with a notion of
  type-free program, and then adds types to describe properties of the
  behavior of programs.  For example, the identity function can be
  described as having type $X \to X$ for any type $X$, as it is
  guaranteed to take an input of type $X$ and return an output of type
  $X$ (namely, the input it was given).  A difficult argument is still
  required to show that typing enforces termination.  But the language
  design is made quite a bit easier by not having types be inherent
  parts of programs.  This is because in reasoning about programs,
  one does not then have to reason about types inside them.  Programs
  are type-free, and typing comes second.  In fact, the slogan I propose
  for this style of type theory is ``Computation First'' (because we
  first explain what type-free programs are and how they execute, and
  only afterwards use types to describe their properties).
\end{enumerate}

Bend2's philosophy can be viewed as a strengthened form of Curry-style
type theory, with the modified slogan: ``Terminating Computation
First''.  The idea, proposed by Victor Taelin, is similar to
Curry-style type theory, where one first defines type-free programs,
and how they compute.  But differently, these programs are designed so
that they are guaranteed to terminate, without reference to any notion
of typing.  Just the structure of the programs and the rules for how
the execute are sufficient to establish that all programs terminate.
Giving a detailed proof of that fact is still not trivial, but
expected to be much simpler than the approaches based on typing.  And
then one has a lot of freedom to design a type system on top of the
terminating type-free language.  Now the only requirement is that the
language should have the usual type-safety property that ones expects
of any statically typed programming language. This is vastly easier to
achieve than crafting a type system that enforces termination.

\section{Bend2's notion of terminating type-free programs}

As it exists currently, Bend2's terminating language is based on a
notion of sizes of values, where values are built from tuples
(including the empty tuple, which is just the unit value familiar from
other functional programming) using labels.  A list, for example, is
just a nested tuple with labels through the nesting that indicate
whether the tuple represents an empty list (and hence has no more
data), or adding an element to the head of another list (which is then
contained inside this tuple).  Terminating recursions operating on
such data just need to be structurally recursive: all recursive calls
should happen on subdata of the input.  Anonymous functions are
restricted to being \emph{affine}, which means they may use their
inputs either one time or not at all.  These restrictions individually
are well-known to enforce termination of type-free programs, and in
combination they should continue to enforce termination (this may be
known, but I am not aware of a proof).

This representation of data as nested tuples is appealingly simple.
It does have the drawback that data need to have a finite size.  In
type theory, however, it is common to work with data structures that
are infinitely branching, but where each branch is finite.  Such
structures do not have a finite size.  One can extend finite sizes to
the ordinals, and then cover such cases.  In fact, ordinals are a
classic (if theoretically motivated) example of such a datatype:

\begin{verbatim}
data Ord = Zero | Succ | Lim (Nat -> Ord)
\end{verbatim}

\noindent The \verb|Lim| constructor has an infinite number of
subtrees, one for each natural number.  This infinite set of subtrees
is represented by having \verb|Lim| accept a function (call it
\verb|f|) from \verb|Nat| to \verb|Ord|.  Given natural number
\verb|i|, the function \verb|f| returns the \verb|i|'th subtree.

Basing a test for structural decrease of programs using ordinals might
be possible, but I do not know of an example of this.  It would
require defining some suitable class of ordinals, and then testing
functions for decrease with respect to that class.  I am not sure how
one would be able to do that in a type-free way, as I am not sure how
one would check, just by seeing how code is manipulating part of a
data structure, that the ordinal measure of the entire data structure
is being decreased.

\section{W-types for general structurally terminating recursion}

An alternative -- which might possibly be viewed as the correct way of
achieving some kind of implicit form of ordinal decrease as just
described -- is to use so-called W-types, proposed by the great type
theorist Per Martin-L\"of (see~\cite[Chapter 15]{mlttprog} for an
introduction).  Of course, with Bend2's strengthened Curry-style
philosophy, we begin not with the types of this proposal, but just the
type-free programs.  There are two constructs, one for constructing
values, and the other for recursing over them.

\subsection{Construction and recursion}

A construction consists of a \emph{label} $l$ and then a function $f$
producing the subdata.  Each input to $f$ is like a name or index for
a piece of subdata, and given that name, $f$ returns the corresponding
subdata.  So for the example above of \verb|Lim| for ordinals, the
name would be a natural number $i$, and the subdata would be the
$i$'th ordinal contained in that limit ordinal.  Let us write
$\ctor{l}{f}$ for this construction with label $l$ and function $f$.
So it is effectively a pair, but the second argument is always a
function.

To recurse over such a value, we write a function $R$ which takes the
label $l$, the function $f$, and also a function $r$ that returns
recursive results.  $R$ then returns a result, generally by calling
$r$.  For each possible input to $f$, the function $r$ returns the
result of recursing on the subdata $f\ i$; that is, the $i$'th piece
of subdata.  The recursor itself takes in $R$ and a piece $d$ of data,
decomposes that data into $l$ and $f$, and then invokes $r$.  In more
detail, let us write $\wrec{R}{d}$ for this.  Then the computation
rule is:

\[
\wrec{R}{\ctor{l}{f}} \ \ = \ \ R\ l\ f\ (\lam{x}{\wrec{R}{(f\ x)}})
\]

\noindent So someone using the recursor writes $R$, and then for each
piece of data $\ctor{l}{f}$, that function $R$ will be invoked with
the label $l$, and the function $f$, which $R$ can then call as needed
to obtain subdata.  The third argument to $R$ is the value that $R$
will use for $r$, namely $\lam{x}{\wrec{R}{(f\ x)}}$.  That function
takes in an index $x$, and recursively invokes the recursor on the
$x$'th piece of subdata, given by $f\ x$.  We can see this in action
through an example.

\section{Examples}

Here are a couple examples of standard datatypes, represented using
this approach.  The examples presuppose a set of labels of the form
``\textsf{@name}'', together with a basic (termination-preserving)
function $\{\textsf{@name}_1 \mapsto t_1\ ;\ \cdots \textsf{@name}_k
\mapsto t_k\}$, which maps input label $\textsf{@name}_i$ to $t_i$,
and is undefined if applied to any label not listed.  Later, the type
system can make sure such functions are always called with a label
from the list.  Also, to serve as a base case for constructions,
assuming we have a unit value $\wunit$.

\subsection{Natural numbers}

We can encode zero and successor as follows:

\[
\begin{array}{lll}
  \textit{Zero} & := & \ctor{\mathsf{@zero}}{\lam{x}{\wunit}} \\
  \textit{Succ} & := & \lam{n}{\ctor{\mathsf{@succ}}{\lam{x}{n}}}
\end{array}
\]

\noindent So for example, the term $\textit{Succ}\ (\textit{Succ}\ \textit{Zero})$
normalizes to
\[
\ctor{\mathsf{@succ}}{\lam{x}{\ctor{\mathsf{@succ}}{\lam{x}{\ctor{\mathsf{@zero}}{\lam{x}{\wunit}}}}}}
\]
\noindent This is not very different from an encoding using just labels and tuples, which would
be
\[
\ctor{\mathsf{@succ}}{\ctor{\mathsf{@succ}}{\ctor{\mathsf{@zero}}{\wunit}}}
\]
\noindent The encoding with W-types has additional lambda abstractions throughout the value, which
the encoding with labels and tuples lack.

Now to recurse on natural numbers, we could either directly use the recursor for W-types defined above,
or we can derive a recursor $\rrec$ specifically for natural numbers using the recursor for W-types:
\[
\rrec := \lam{s}{\lam{z}{\lam{n}{\wrec{\{\textsf{@zero} \mapsto \lam{p}{\lam{r}{z}}\ ;\ \textsf{@succ} \mapsto \lam{p}{\lam{r}{s\ (p\ \wunit)\ (r\ \wunit)}}\}}{n}}}}
\]
\noindent Given a function $s$ to apply when the input $n$ is a successor, and a value $z$ to return if $n$ is zero, this
term applies the W-type recursor on the value $n$, with a function that takes action based on the label.  In both
cases, the function takes inputs $p$ and $r$, where $p$ is a function returning the predecessor number if the number is non-zero, and
$r$ is a function returning the result of recursion on that value (again, if the number is non-zero).
\begin{itemize}
\item If the label is \textsf{@zero}, then the subdata function and recursion function are both unused, because
  \textit{Zero} has no subdata.  The function just
    returns $z$ in this case.
  \item If the label is \textsf{@succ}, then the function calls $s$ on
    the predecessor and the result of recursion for the predecessor.
    Those values are obtained by calling $p$ and $r$, respectively,
    with $\wunit$ as input.  Actually, in the type-free setting, it
    does not matter what input is used, as $p$ and $r$ are both
    constant functions, which discard their inputs.
\end{itemize}

Using $\mathsf{R}_{\textit{Nat}}$, one may then define the usual arithmetic functions in a standard way.  For example, addition may be defined as:
\[
\textit{add}\ :=\ \lam{x}{\lam{y}{\rrec\ (\lam{p}{\textit{Succ}})\ y\ x}}
\]
\noindent This definition uses $\rrec$ to iterate the successor function -- well, actually a function which first discards the predecessor,
which $\rrec$ always supplies when invoking the step case of the recursion -- starting with $y$.  And since we are writing recursors here
instead of iterators, we can write a constant-time predecessor function:
\[
\textit{pred}\ :=\ \rrec\ (\lam{p}{\lam{r}{p}})\ \textit{Zero}
\]
\noindent The predecessor $p$ is given to the step case of the recursion, which returns it.

\subsection{Ordinals}

The example of ordinals given above can be implemented using W-types.  Here are definitions of the three constructors:
\[
\begin{array}{lll}
  \textit{Zero} & := & \ctor{\mathsf{@zero}}{\lam{x}{\wunit}} \\
  \textit{Succ} & := & \lam{n}{\ctor{\mathsf{@succ}}{\lam{x}{n}}} \\
  \textit{Lim} & := & \lam{f}{\ctor{\mathsf{@lim}}{f}}
\end{array}
\]
\noindent While we are still type-free here, intuitively, \textit{Lim} is taking in a function from $\textit{Nat}$ to $\textit{Ord}$, and
installing that function as the second component of the construction labeled \textsf{@lim}.  This means that we can obtain the $i$'th smaller
ordinal from a limit ordinal just by calling that function $f$ with $i$.

Using this definition, we can define ordinal addition:
\[
\begin{array}{lll}
  \textit{add} & := & \lam{n}{\lam{m}{\ }} \\
  \ & \ & \ \ \ \ \ \{\mathsf{@zero} \mapsto \lam{p}{\lam{r}{n}} ;  \\
  \ & \ & \ \ \ \ \ \ \, \mathsf{@succ} \mapsto \lam{p}{\lam{r}{\textit{Succ}\ (r\ \wunit)}}; \\
  \ & \ & \ \ \ \ \ \ \, \mathsf{@lim} \mapsto \lam{p}{\lam{r}{\textit{Lim}\ r}} \}\ \bullet\ m
\end{array}
\]
\noindent This definition works, because in the \textsf{@lim} case,
the function $r$ will add the $i$'th sub-ordinal of the limit, to $m$.
But this is exactly what we want to take the limit of, and so we just
write $\textit{Lim}\ r$.  So W-types can support ordinal arithmetic.
Proving theorems about such operations is involved, however, and there
is quite a bit that can be studied about constructive theories of
ordinals~\cite{kraus23}.  Here, the point is just to demonstrate
terminating recursion with a generalized inductive datatype (one
where values might not have finite sizes).

\subsection{Pairs}

There are several ways one could implement construction of pairs $(x,y)$. In the context of affine typing, it might be
best just to lambda-encode these:
\[
\begin{array}{lll}
  (x,y) & := & \lam{c}{c\ x\ y}
\end{array}
\]
\noindent This would allow an affine way to decompose the pair.  One
could also add pairs with pattern-matching \emph{let} as primitive.
Finally, one could define pairs with W-types this way:
\[
\begin{array}{lll}
  (x,y) & := & \ctor{\wunit}{\{\mathsf{@fst} \mapsto x;\ \mathsf{@snd} \mapsto y\}} \\
  \textit{fst} & := & \lam{p}{\wrec{(\lam{l}{\lam{f}{f\ \mathsf{@fst}}})}{p}} \\
  \textit{snd} & := & \lam{p}{\wrec{(\lam{l}{\lam{f}{f\ \mathsf{@snd}}})}{p}} 
\end{array}
\]
\noindent To extract the first value from a pair $\ctor{\wunit}{f}$,
you call $f\ \mathsf{@fst}$, and similarly $f\ \mathsf{@snd}$ for the
second value.  But then you cannot get both components of the pair
in an affine way.

For examples below, I will assume we have a function \textit{open}
with the following computation rule:
\[
\textit{open}\ (x,y)\ f = f\ x\ y
\]
\noindent It is trivial to implement \textit{open} using lambda-encoded
pairs, as I am proposing.

\subsection{Lists and non-recursive subdata}

The datatype of lists is famously similar to $\textit{Nat}$.  Both
have a non-recursive constructor, namely \textit{Nil} for
\textit{List} and \textit{Zero} for \textit{Nat}; as well as a
recursive constructor, namely \textit{Cons} for \textit{List} and
\textit{Succ} for \textit{Nat}.  The sole difference is that for
lists, the recursive constructor takes extra data of some type $A$.
This results in a type $\textit{List}\ A$ of lists storing values of
type $A$.

The standard representation of lists with W-types is slightly annoying, because
the non-recursive data is included in the label of the construction.
To prepend head $h$ to tail $t$, the code is:
\[
\textit{Cons}\ :=\ \lam{h}{\lam{t}{\ctor{(\mathsf{@cons},h)}{\lam{x}{t}}}}
\]
\noindent So the head $h$ of the list is stored in the first component
of the W-type construction, along with the \textsf{@cons} label.  For
uniformity (so that given a list of unknown form, we can find the
label telling whether it is a \textsf{@cons} or a \textsf{@nil}), one
then needs the label to be a pair also in the nil case:
\[
\textit{Nil}\ :=\ \ctor{(\mathsf{@nil},\wunit)}{\lam{x}{\wunit}}
\]
\noindent We just store some trivial data $\wunit$ in the label, along with \textsf{@nil}.
This is a little clunky, because then a function like append needs to dig in a level to the label part of the construction,
to find out which case should be applied:
\[
\textit{append}\ :=\ \lam{x}{\lam{y}{\wrec{(\lam{q}{\lam{p}{\lam{r}{\textit{open}\ q\ (\lam{l}{\lam{d}{\{ \mathsf{@cons}\mapsto \textit{Cons}\ d\ (r\ \wunit); \mathsf{@nil}\mapsto y\}\ l}})}}})}{x}}}
\]
\noindent This function takes in two lists $x$ and $y$, and then uses the W-type recursor to recurse on $x$.  The first part (to the left of the $\bullet$ symbol) of the W-type recursor takes in the label $q$, subdata function $p$, and recursion function $r$, and then opens the label $q$ to see what kind of list we have.  When we open $q$, we will get a label $l$ (either \textsf{@cons} or \textsf{@nil}), and a piece of non-recursive data $d$.  In the \textsf{@cons} case, this $d$ is the head of the input list, which we use to rebuild the list around the result $r\ \wunit$ of recursing on the tail of the input list.  In the \textsf{@nil} case, of course, we just return the second list $y$.

\subsection{Factoring out nonrecursive data}

It would be reasonable to change the format of W-types so that the construction explicitly has a place for nonrecursive data.  So we would have
\[
\ctora{l}{n}{f}
\]
\noindent where $n$ is just the nonrecursive data associated with the given label, and $f$ remains the function which returns subdata.  The syntax of the W-type recursor would remain the same, but its computation rule would change as follows:
\[
\wrec{R}{\ctora{l}{n}{f}} \ \ = \ \ R\ l\ n\ f\ (\lam{x}{\wrec{R}{(f\ x)}})
\]
\noindent So the function $R$ which is being folded over the constructor value would be given
the nonrecursive subdata $n$ explicitly, as an extra argument.  Everything else is the same
as before.  With this simple modification, lists could be written more naturally as
follows:
\[
\begin{array}{lll}
\textit{Cons} & := & \lam{h}{\lam{t}{\ctora{\mathsf{@cons}}{h}{\lam{x}{t}}}} \\
\textit{Nil} & := & \ctora{\mathsf{@nil}}{\wunit}{\lam{x}{\wunit}} \\
\textit{append} & := & \lam{x}{\lam{y}{\wrec{(\lam{l}{\lam{h}{\lam{p}{\lam{r}{\{ \mathsf{@cons}\mapsto \textit{Cons}\ d\ (r\ \wunit); \mathsf{@nil}\mapsto y\}\ l}}}})}{x}}}
\end{array}
\]
\noindent Now \textit{append} is more natural, because the function we are folding over the first list $x$ takes in the label $l$ (which is either \textsf{@cons} or \textsf{@nil}), and then the nonrecursive data $h$.  If $l$ is \textsf{@cons}, then $h$ is the head of the list, which we
use as before.  The code no longer needs to open the first component of the W-type construction to see what kind of list this is.

\section{Adding types}

Now that we have considered the type-free definitions of construction
and recursion for W-types, let us consider how to type them.  We will
use the version of W-types factoring out nonrecursive data, as
described in the previous section.  We do not need to be too specific
about the other typing features available, but they should include at
least function types and a kind $\star$ to be the classifier for
types (so $\textit{Bool} : \star$, for example).  Also, there should
be enumeration types $\{\mathsf{l}_1 , \cdots , \mathsf{l}_k\}$ describing
set of labels.  We should have a unit type $\wunit$ for the $\wunit$ value (so with typing
$\wunit : \wunit$).  Finally, I write $\perp$ for an empty type (with no
inhabitant $t : \perp$).

First, we need to add a new primitive type form for W-types, to describe
constructions $\ctora{l}{n}{f}$, where (to recall) $l$ is a label indicating
which constructor is used, $n$ is the nonrecursive data, and
$f$ is a function returning subdata.  To type such a construction, we
clearly need:
\begin{itemize}
\item a type $L$ for the label $l$
\item a type constructor $N$ where $N\ l$ is the type for the nonrecursive data
\item a type constructor $R$ where $R\ l$ is the type for inputs to the function $f$
\end{itemize}
\noindent $N$ and $R$ are type constructors (that is, functions returning types), because
we need to describe the types for each possible label $l$.  So given a label $l$, we need
to know what the type will be for nonrecursive data of a construction labeled $l$, for example.
In the case of the recursive subdata, only the input type of $f$ needs to be specified, because the output
type is determined already: given an index (like the natural number $i$ selecting the $i$'th smaller
ordinal for a \textit{Limit}), $f$ returns a piece of subdata, which recursively
has the W-type again.  I propose this syntax:
\[
\w{L}{N}{R}
\]
\noindent Following the above discussion, this has kind $\star$ (so it is a type) assuming
\begin{itemize}
\item $L$ has kind $\star$
\item $N$ and $R$ both have kind $L \to \star$
\end{itemize}

\noindent If one wanted to ensure that the top-level syntactic form of an expression
determined whether that expression is a term, type, or kind, then it would be necessary
to pick a slightly different syntax, maybe $\wb{L}{N}{R}$ or (if one avoids Unicode) $\wc{L}{N}{R}$.
In my opinion, it is rather nicer just to reuse the term syntax, if possible, the way
Haskell does for tuples as values and tuple types (for example, $(\textit{True},\textit{"hi"}) : (\textit{Bool},\textit{String})$).

The typing rule for W-types as just described would then be:
\[
\infer{ \w{L}{N}{R} : \star}{L : \star & N : L \to \star  & R : L \to \star }
\]
\noindent This records exactly the same information as in the informal
description: the three premises just say what we wrote above, that $L$
has kind $\star$ ($L : \star$), and so forth.  Usually typing rules
prove statements of the form $\Gamma \vdash t : T$, where $\Gamma$ is
a set of assumptions about the types or kinds of free variables.  But
for W-types we will not need to modify the typing context, so it can
just be elided throughout the rules.  This will make them easier to
read.


\subsection{Example: the type for lists}

\noindent The type of lists storing data of type $A$ would be defined as
\[
\w{\{\mathsf{@cons},\mathsf{@nil}\}}{\{\mathsf{@nil} \mapsto \wunit ; \mathsf{@cons} \mapsto A\}}{\{\mathsf{@nil} \mapsto \perp ; \mathsf{@cons} \mapsto \wunit\}}
\]
\noindent Here, the type $L$ of labels is $\{\mathsf{@cons},\mathsf{@nil}\}$.  The type constructor $N$ describing the
nonrecursive data is
\[
\{\mathsf{@nil} \mapsto \wunit ; \mathsf{@cons} \mapsto A\}
\]
\noindent This is indeed a function from the type $L$ to $\star$.  $N$
returns $\wunit$ for \textsf{@nil}, because \textsf{@nil} lists have
no nonrecursive data; and $N$ returns $A$ for $\textsf{@cons}$, for the
type of the head of the list.

Finally, the type constructor $R$ is 
\[
\{\mathsf{@nil} \mapsto \perp ; \mathsf{@cons} \mapsto \wunit\}
\]
\noindent Recall that $R$ is supposed to tell you the type for inputs
to the function $f$ in a construction $\ctora{l}{n}{f}$.  Those inputs
are the indices into the collection of subdata, like the tail of a
nonempty list or the subordinals of a Limit ordinal. Empty lists have
no subdata, so one should not be able to call $f$ at all if $l$ is
\textsf{@nil}.  That is why the input type for $f$ is $\perp$.  From a
typing perspective, calling $f$ must return some subdata, of type
$\textit{List}\ A$ (which is defined to be this W-type) again.  Since
a \textsf{@nil} list truly has no subdata, we must make sure it is
impossible to call $f$, which we do by making $f$ require an input
that cannot possibly exist (unless in code which is already itself
taking in an input of type $\perp$, but then that code cannot be
called either).  $R$ returns $\wunit$ if the label is \textsf{@cons},
because there is just one piece of subdata for a non-empty list,
namely the tail.  So given $\wunit$ as an input, $f$ will return the
tail.  Notice that it would not be correct to use a type with more
inhabitants than $\wunit$ as the value for $R\ \mathsf{@cons}$,
because then the $\textit{List}\ A$ type would also abstract values
that held multiple pieces of subdata for \textsf{@cons} lists.  But
lists are supposed to be linear data structures, so there should just
be one piece of subdata for \textsf{@cons} lists.

\subsection{The typing rule for constructions}

Now let us see the typing rule for constructions $\ctora{l}{n}{f}$.  For this
to have a W-type of the form $\w{L}{N}{R}$ we were just discussing, what has
to be true?

\begin{itemize}
\item The label $l$ certainly has to have the type $L$ for labels.
\item The nonrecursive data $n$ should have the type $N\ l$ that
  the type constructor says should be there if the label is $l$.
\item The function $f$ needs to take in a value of type $R\ l$,
  because this is the type for indices into the collection of subdata,
  and such an index is what $f$ expects as input. It should return a
  result of the W-type, namely the subdata for the given index..
\end{itemize}

Formalizing these ideas, we get the following typing rule:
\[
\infer{\ctora{l}{n}{f} : \w{L}{N}{R}}
      {l : L & n : N\ l & f : R\ l \to \w{L}{N}{R}}
      \]
      
\subsection{The typing rule for recursion}

A recursion $\wrec{R}{t}$ takes in a function $R$ and a value $t$ of the W-type.
Recalling the computation rule will help us understand what the typing of a recursion
should be:
\[
\wrec{R}{\ctora{l}{n}{f}} \ \ = \ \ R\ l\ n\ f\ (\lam{x}{\wrec{R}{(f\ x)}})
\]
\noindent We know from the typing rule for constructions that for some $L$, $N$, and $R$, we will have
\[
\begin{array}{lll}
  l & : & L \\
  n & : & N\ l \\
  f & : & R\ l \to \w{L}{N}{R}
\end{array}
\]
\noindent Since $R$ takes in those inputs on the right-hand side of the computation rule,
we know that the type of $R$ must look like:
\[
\Pia{l}{L}{\Pia{n}{N\ l}{\Pia{f}{R\ l \to \w{L}{N}{R}}{\cdots}}}
\]
\noindent We just need to fill in the missing part of this type.  We expect that
the recursion is going to compute a value of some type constructor $C$ which might
be a function of the input value $\ctora{l}{n}{f}$.  So $C$ will have kind
\[
\w{L}{N}{R} \to \star
\]
\noindent This is similar to how a recursion on natural numbers $n$ can compute a value of type $P\ n$,
which is used, for example, when reasoning by induction on $n$.  Now what type will the final (fourth)
input of $R$ on the right-hand side of the computation rule have?  That input is
\[
\lam{x}{\wrec{R}{(f\ x)}}
\]
\noindent It is taking in a value of type $R\ l$, just as the subdata function $f$ does.  And it returns
a value of type $C$ (since it is recursing).  $C$ depends on the input to the recursion, so in this case,
since $f\ x$ is the input, the result of the recursion will have type $C\ (f\ x)$.  This means that the
type for $\lam{x}{\wrec{R}{(f\ x)}}$ is
\[
\Pia{x}{R\ l}{C\ (f\ x)}
\]
\noindent Putting all this together, the type of $R$ should be:
\[
\begin{array}{l}
  \Pia{l}{L}{\ }\\
  \Pia{n}{N\ l}{\ }\\
  \Pia{f}{R\ l \to \w{L}{N}{R}}{\ } \\
  (\Pia{x}{R\ l}{C\ (f\ x)}) \to \\
  C\ \ctora{l}{n}{f}
  \end{array}
\]
\noindent Finally, the type of $\wrec{R}{d}$ is $C\ d$.  So if we think of $\wrec{R}{d}$
as a proof by induction, it is saying that to prove a property $C$ of some value $d$ of
type $\w{L}{N}{R}$, it is sufficent to assume

\begin{itemize}
\item $l : L$
\item $n : N\ l$
\item $f:R\ l \to \w{L}{N}{R}$
\end{itemize}

\noindent and show $C\ \ctora{l}{n}{f}$, assuming for induction hypothesis
\[
\Pia{x}{R\ l}{C\ (f\ x)}
\]
\noindent That type expresses that $C$ holds for all the subdata that $f$ can produce.

\bibliographystyle{plain}
\bibliography{main}

\end{document}
