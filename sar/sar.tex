\documentclass{article}

\usepackage{amsmath,amssymb,amsthm}
\usepackage{url}
\usepackage{hyperref}
\usepackage{proof}
\usepackage{stmaryrd}
\usepackage{xspace}
\usepackage{parskip}
\usepackage{fullpage}
\usepackage{float}

\setlength{\topsep}{1em}

\begin{document}

\include{definitions}

\title{Type in Type and Schematic Affine Recursion}

\author{Aaron Stump and Victor Taelin}

\maketitle

\section{Terminating Computation First}

Constructive type theories based on the Curry-Howard isomorphism
enforce logical soundness by ensuring that all programs are uniformly
terminating.  Proofs are identified with programs, and diverging
programs would thus prove arbitrary propositions.  So these must be
ruled out statically.  The approach adopted in systems like Coq, Agda,
and Lean is to enforce termination through a combination of typing
and syntactic checks for structural decrease at recursive calls.

This paper proposes an alternative, where termination is enforced
through syntactic checks alone, prior to typing.  The approach has the
drawback that programs must be significantly restricted in order to
guarantee termination without any reference to types.  There is a
notable benefit, however: the type system is now no longer required to
enforce termination.  This greatly increases the options for the
typing relation, which now needs only to satisfy type safety, as
required in Programming Languages.

We present a language \sar, which combines an untyped affine lambda
calculus with a form of structural recursion.  With no further
restriction, this language allows diverging terms.  So we impose what
Alves et al. call the ``closed-by-construction'' restriction on
structural recursion~\cite{alves10}, found also in~\cite{dallago09}.
This requires that the functions to be iterated when recursing are
closed.  But this rules out most of the usual higher-order functions
like \texttt{map} on lists, where the function to iterate calls a
function $f$ that is given as a variable bound outside the recursion.
We address this problem by proposing a language of schematic terms,
where such variables $f$ are not $\lambda$-bound, but treated
schematically.  This allows generic definition of functions like
\texttt{map}, without losing termination.

With termination of \sar established prior to typing, we are free to
adopt a more exotic type system than possible in other constructive
type theories, where the burden of termination falls on typing.  To
demonstrate this, we consider a dependent type system called Typed
\sar, with the $\star : \star$ principle.

\section{Previous work on termination with affine recursion}
\label{sec:prevaff}

Affine lambda calculus restricts $\lambda$-abstractions so that the
$\lambda$-bound variable may occur at most once in the body of the
abstraction.  With this restriction, $\beta$-reduction is easily seen
to be terminating, as the number of applications decreases by at least
one with every $\beta$-step.

\begin{figure}
  \[
  \begin{array}{llll}
    \textit{Terms} & t & ::= & x\ |\ \lam{x}{t}\ |\ t\ t'\ |\ \mathsf{Nil}\ |\ \mathsf{Cons}\ t_1\ t_2\ |\ \mathsf{R}\ t_1\ t_2\ t_3
  \end{array}
  \]
  \caption{The syntax of untyped terms}
\label{fig:syn}
\end{figure}

But affine lambda calculus seems too restrictive for regular
programming.  For example, Church-encoded data such as natural numbers
and lists are not affine in general.  So we consider expanding the
language with some form of inductive datatype, and its structural
recursor.  For simplicity, in this paper we just consider a datatype of lists, with its
recursor.  The syntax is shown in Figure~\ref{fig:syn}, and its reduction semantics in Figure~\ref{fig:redsem}.

\begin{figure}
  \[
  \begin{array}{lll}
    (\lam{x}{t})\ t' & \leadsto & [t'/x]t \\
    \mathsf{R}\ \mathsf{Nil}\ t_1\ t_2 & \leadsto & t_2 \\
    \mathsf{R}\ (\mathsf{Cons}\ t_a\ t_b)\ t_1\ t_2 & \leadsto & t_1\ t_a\ t_b\ (\mathsf{R}\ t_b\ t_1\ t_2)
  \end{array}
  \]
  \caption{Reduction semantics}
\label{fig:redsem}
\end{figure}

\noindent Without some further restriction, this language is
easily seen to allow diverging terms.  Let us see an example, adapted
from~\cite{alves10}.  Define
\begin{eqnarray*}
  \texttt{app}_t & = & \lam{y}{y\ t} \\
  \texttt{apply} & = & \lam{a}{\lam{b}{a\ b}} \\
\end{eqnarray*}
\noindent where $\texttt{app}_t$ is schematic in meta-variable $t$. Then we have this reduction sequence, for any term $t$:
\[
\begin{array}{ll}
  \texttt{app}_t\ (\texttt{app}_t\ \texttt{apply}) & \leadsto^2 \\
  \texttt{app}_t\ (\lam{b}{t\ b}) & \leadsto^2 \\
  t\ t& \
  \end{array}
\]
\noindent The example is easier to complete with an iterator, defined as
\[
\texttt{It} = \lam{n}{\lam{f}{\lam{x}{\mathsf{R}\ n\ (\lam{q}{\lam{r}{f}})\ x}}}
\]
\noindent This uses \textsf{R} to repeat the function $f$, but dropping the head
and tail of the list that \textsf{R} supplies to its second argument in case the first is a \textsf{Cons}.  Using \texttt{It}, define
\begin{eqnarray*}
\texttt{u} & = & \lam{x}{x} \\
\texttt{T} & = & \mathsf{Cons}\ u\ (\mathsf{Cons}\ u\ \mathsf{Nil}) \\
\delta & = & \lam{x}{\texttt{It}\ \texttt{T}\ \texttt{app}_x\ \texttt{apply}}
\end{eqnarray*}

\noindent \texttt{T} is a list of length two, and applying \texttt{It} with it
will lead to two nested calls.  So we have
\[
\begin{array}{ll}
  \texttt{It}\ s\ \texttt{app}_x\ \texttt{apply} & \leadsto^+ \\
  \texttt{app}_x\ (\texttt{app}_x\ \texttt{apply}) & \leadsto^+ \\
  x\ x& \
\end{array}
\]
\noindent So the term $\Omega = \delta\ \delta$ is not normalizing, 
because $\delta$ reduces to $\lam{x}{x\ x}$.

This example is not so surprising, since the reduction rule for
\textsf{R} is (at the meta-level) not affine.  What is more surprising
is that the example still is diverging if one adopts what Alves et al.
call the ``closed at reduction'' restriction on the reduction
rules for \textsf{R}:
  \[
  \begin{array}{lllll}
    \mathsf{R}\ \mathsf{Nil}\ t_1\ t_2 & \leadsto & t_2, & \textnormal{if } \textit{FV}(t_1) = \emptyset\\
    \mathsf{R}\ (\mathsf{Cons}\ t_a\ t_b)\ t_1\ t_2 & \leadsto & t_1\ t_a\ t_b\ (\mathsf{R}\ t_b\ t_1\ t_2),& \textnormal{if } \textit{FV}(t_1) = \emptyset
  \end{array}
  \]
\noindent With the ``closed at reduction'' restriction, the former
reduction sequence is not available.  But we still have this one:
\[
\begin{array}{ll}
  \delta\ \delta & \leadsto \\
  \texttt{It}\ \texttt{T}\ \texttt{app}_\delta\ \texttt{apply} & \leadsto^+ \\
  \texttt{app}_\delta\ (\texttt{app}_\delta\ \texttt{apply}) & \leadsto^+ \\
  \delta\ \delta& \
\end{array}
\]
\noindent showing that $\Omega$ diverges.

Alves et al. observe that if one goes even further and restricts the
syntax so that $\mathsf{R}\ t\ t_1\ t_2$ is only syntactically allowed
if $t_1$ is closed, then the language is indeed terminating.  They
call this the ``closed at construction'' restriction.  It
significantly reduces the computational power of the language: only
the primitive recursive functions are definable~\cite{alves10}.

While limiting oneself to primitive recursive functions may be a
concern for theoretical applications, it is not a concern for
practical programming, where the primitive recursive functions already
encompass computations far beyond the feasible.  But ``closed at construction''
does have a serious practical drawback: it prevents the usual higher-order
combinators one expects in functional programming.  For example, using the
unrestricted syntax, we may define a \texttt{map} function on lists:
\[
\texttt{map} = \lam{f}{\lam{x}{\mathsf{R}\ x\ (\lam{h}{\lam{t}{\lam{r}{\mathsf{Cons}\ (f\ h)\ r}}})\ \mathsf{Nil}}}
\]
\noindent Here, \textsf{R} is used to recurse through list $x$,
applying $f$ to the head $h$ of each sublist.  But the term performing
that application has $f$ free.  So this program, along with many
others from usual functional programming practice, will be disallowed
by affine lambda calculus with ``closed at construction'' recursion.

\section{Schematic affine recursion}
\label{sec:sar}

We can address this difficulty by applying a basic idea that one finds
in both Logic and Programming Languages, namely the use of schematic
constructions.  For the definition of Peano Arithmetic in first-order
logic, one postulates a \emph{scheme} of induction.  This is a
meta-level formulation representing an infinite set of axioms, each
one expressing the induction principle for proving $\all{x}{\phi}$
from base and step cases.  This is in contrast to second-order logic,
where a single axiom suffices, by quantifying, within the logic, over
the formula $\phi$.  In contrast, the first-order scheme of induction
is a meta-level quantification, outside the logic, over $\phi$.

We can use this same method here to recover generic programming while
respecting the ``closed at construction'' requirement.  We extend the
syntax of Figure~\ref{fig:syn} to allow top-level schematic
definitions of terms.  This is shown in Figure~\ref{fig:sarsyn}.
Schematic terms have the same syntax as terms above, except
for the addition of the construct $\mathbf{f}[\bar{t}]$.  Here,
$\bar{t}$ is a (finite) vector of schematic terms, and $\mathbf{f}$ is
a defined symbol.  Figure~\ref{fig:sarwf} defines a relation $\textit{Wf}$
on lists of definitions, imposing these requirements:
\begin{itemize}
\item The defined symbols occurring on the right-hand side of a definition
  are defined earlier in the list, with
  the same number of schematic variables $\bar{u}$ as the arguments $\bar{t}$
  where that symbol is applied.
\item In applications $\mathbf{f}[\bar{t}]$, the terms $\bar{t}$ are
  all required to be closed, which means that they have no free variables
  except for schematic ones.  Those will only be instantiated by closed
  terms, so they may stand for such in applications of defined symbols.
\item The term $t_1$ in a recursion $\mathsf{R}\ t_1\ t_2\ t_3$ is
  required to be closed.
  \end{itemize}
These requirements are imposed using the following relations:
\begin{itemize}
\item $\textit{Wf}\ \Delta$ expresses that the list $\Delta$ of
  schematic definitions is well-formed, in the sense that
each definition in $\Delta$ is well-formed with respect to the definitions
to the left of it in $\Delta$.
\item The relation $\Delta \vdash \textit{Wf}\ D$ expresses
  that definition $D$ is well-formed with respect to $\Delta$.  This requires, for definition
  $\mathbf{f}[\bar{u}] = t$, that the body $t$ of the
  definition is closed with respect to the parameters $\bar{u}$, and
  (for simplicity) that $\mathbf{f}$ is not declared already in $\Delta$.
\item The relation $\Delta; \bar{u}\ |\ \bar{x} \vdash
  \textit{Closed}\ t$ means that term $t$ is closed with respect to
  the definitions in $\Delta$ (which are just used to check that
  defined symbols $\mathbf{f}$ are applied to the correct number of
  arguments), and the parameters $\bar{u}$.  The parameters are
  considered closed themselves, as are the locally bound variables
  $\bar{x}$.  Those variables are dropped, however, in premises
  (of the rules of Figure~\ref{fig:sarwf}) where
  terms must not contain any free local variables.  Dropping them
  enforces that the terms in question cannot contain free local variables.
  This can be seen
  where $\bar{x}$ is replaced with $\cdot$ in premises to the rules
  expressing closedness of $\mathsf{R}$-terms and applications
  $\mathbf{f}[\bar{t}]$ of defined symbols.
\end{itemize}

\begin{figure}
  \[
  \begin{array}{llll}
   \textit{Defined symbols} & \mathbf{f} & \ &\ \\
   \textit{Schematic variables} & u & \ &\ \\
    \textit{Schematic terms} & t & ::= & x\ |\ u\ |\ \mathbf{f}[\bar{t}]\ |\ \lam{x}{t}\ |\ t\ t'\ |\\
    \ &\ &\ & \mathsf{Nil}\ |\ \mathsf{Cons}\ |\ \mathsf{R} \\
    \textit{Definitions} & D & ::= & \mathbf{f}[\bar{u}] = t \\
    \textit{Lists of definitions} & \Delta & ::= & \cdot \ |\ \Delta, D
  \end{array}
  \]
  \caption{Syntax of \sar}
\label{fig:sarsyn}
\end{figure}

\begin{figure}
  \[
  \begin{array}{lll}
    \infer{\textit{Wf}\ \cdot}{\ } &
    \infer{\textit{Wf}\ (\Delta,\ D)}{\textit{Wf}\ \Delta & \Delta \vdash \textit{Wf}\ D}
    &\
    \\ \\
    \infer{\Delta\vdash\textit{Wf}\ \ \mathbf{f}[\bar{u}] = t}
          {\begin{array}{l}
              \Delta; \bar{u}\ |\ \cdot \vdash\textit{Closed}\ t\\
          \all{\bar{u}'}{\all{t'}{(\mathbf{f}[\bar{u}'] = t')\not\in \Delta}} \end{array}} &
    \infer{\Delta; \bar{u}\ |\ \bar{x} \vdash\textit{Closed}\ u }{u \in \{\bar{u}\}} &
    \infer{\Delta; \bar{u}\ |\ \bar{x} \vdash\textit{Closed}\ x }{x \in \{\bar{x}\}} 
  \\ \\           
  \infer{\Delta;\bar{u}\ |\ \bar{x} \vdash\textit{Closed}\ \lam{y}{t}}{\Delta;\bar{u}\ |\ \bar{x},y \vdash\textit{Closed}\ t} &
  \infer{\Delta;\bar{u}\ |\ \bar{x} \vdash\textit{Closed}\ (t_1\ t_2)}{\begin{array}{l}\Delta;\bar{u}\ |\ \bar{x} \vdash\textit{Closed}\ t_1\\
                                                                                       \Delta;\bar{u}\ |\ \bar{x} \vdash\textit{Closed}\ t_2
                                                                       \end{array}} &
  \infer{\Delta;\bar{u}\ |\ \bar{x} \vdash\textit{Closed}\ \mathsf{Nil}}{\ }
  \\ \\
  \infer{\Delta;\bar{u}\ |\ \bar{x} \vdash\textit{Closed}\ \mathsf{Cons}\ t_1\ t_2}
         {\begin{array}{l}\Delta;\bar{u}\ |\ \bar{x} \vdash\textit{Closed}\ t_1\\
                          \Delta;\bar{u}\ |\ \bar{x} \vdash\textit{Closed}\ t_2
         \end{array}} &
  \infer{\Delta;\bar{u}\ |\ \bar{x} \vdash \textit{Closed}\ \mathsf{R}\ t_1\ t_2\ t}
        {\begin{array}{l}
         \Delta;\bar{u}\ |\ \cdot \vdash\textit{Closed}\ t_1\\
         \Delta;\bar{u}\ |\ \bar{x} \vdash\textit{Closed}\ t_2\\
         \Delta;\bar{u}\ |\ \bar{x} \vdash\textit{Closed}\ t
         \end{array}}
   &\infer{\Delta;\bar{u}\ |\ \bar{x}\vdash\textit{Closed}\ \mathbf{f}[\bar{t}]}
        {\begin{array}{l}
             (\mathbf{f}[\bar{u}] = t) \in \Delta \\
            |\bar{u}| = |\bar{t}| \\
           \Delta;\bar{u}\ |\ \cdot \vdash \textit{Closed}\ \bar{t}
         \end{array}} 
\\ \\
\infer{\Delta;\bar{u}\ |\ \bar{x}\vdash \textit{Closed}\ \cdot}{\ }&
\infer{\Delta;\bar{u}\ |\ \bar{x}\vdash \textit{Closed}\ (t,\bar{t})}
  {\begin{array}{l}
    \Delta;\bar{u}\ |\ \bar{x}\vdash \textit{Closed}\ t \\
    \Delta;\bar{u}\ |\ \bar{x}\vdash \textit{Closed}\ \bar{t}
\end{array}}&\ 
   \end{array}
  \]
  \caption{Well-formedness of definitions and lists of definitions; closed schematic terms and lists of such terms}
\label{fig:sarwf}
\end{figure}

\subsection{Example}

We may define higher-order functions like \texttt{map} using a schematic definition:
\[
\texttt{map}[f] = \lam{x}{\mathsf{R}\ x\ (\lam{h}{\lam{t}{\lam{r}{\mathsf{Cons}\ (f\ h)\ r}}})\ \mathsf{Nil}}
\]
\noindent Call this definition $D_{\texttt{map}}$.  We have $\textit{Wf}\ D_{\texttt{map}}$, because the
body of the definition, namely
\[
\mathsf{R}\ x\ (\lam{h}{\lam{t}{\lam{r}{\mathsf{Cons}\ (f\ h)\ r}}})\ \mathsf{Nil}
\]
\noindent is closed with respect the parameter $f$.  Being closed
means that the term iterated by \textsf{R} should have no free
variables.  Here, this is the term beginning $\lambda\, h$.  It may,
however, use the parameter $f$, as indeed it does.

It is possible to define the problematic term $\delta$ from
Section~\ref{sec:prevaff} above, as a schematic term.  We first
must define $\mathbf{It}$ schematically:
\[
\mathbf{It}[f] = \lam{n}{\lam{x}{\mathsf{R}\ n\ (\lam{q}{\lam{r}{f}})\ x}}
\]
\noindent This is necessary so that the second argument to $\mathsf{R}$ will
be closed except for parameters (here, \textit{f}).  Note that this definition
reverses the order of the first two arguments to \textbf{It}, compared to the definition
in Section~\ref{sec:prevaff}.  Now using $\mathbf{It}$,
we can define $\delta$ schematically, where $\mathbf{T}$ is, as above, a list of length two:
\[
\begin{array}{lll}
\mathbf{u} & = & \lam{x}{x} \\
  \mathbf{T} & = & \mathsf{Cons}\ \mathbf{u}\ (\mathsf{Cons}\ \mathbf{u}\ \mathsf{Nil}) \\
  \delta[u] & = & \mathbf{It}[\texttt{app}_u]\ \mathbf{T}\ \texttt{apply}
\end{array}
\]
\noindent This is a well-formed definition, because the argument supplied for
the parameter of $\mathbf{It}$ is closed with respect to parameter $u$.

So we could define $\mathbf{It}$ and $\delta$.  What breaks down is
the definition of $\Omega$.  Here, as $\delta$ is a schematic term, it
must be supplied with a closed term.  We cannot write $\delta[\delta]$
because $\delta$ cannot be used as an argument: it is not a closed
term, but requires a closed term as an argument for its parameter.
This shows that restricting terms to be closed with respect to
schematic definitions blocks the counterexample above to termination.

\subsection{Reduction}

\begin{figure}
  \[
  \begin{array}{llll}
    (\lam{x}{t})\ t' & \leadsto_\Delta & [t'/x]t &\ \\
    \mathsf{R}\ \mathsf{Nil}\ t_1\ t_2 & \leadsto_\Delta & t_2 &\ \\
    \mathsf{R}\ (\mathsf{Cons}\ t_a\ t_b)\ t_1\ t_2 & \leadsto_\Delta & t_1\ t_a\ t_b\ (\mathsf{R}\ t_b\ t_1\ t_2) &\ \\
    \mathsf{f}[\bar{t}] & \leadsto_\Delta & [\bar{t}/\bar{u}]t & \textnormal{if }(\mathsf{f}[\bar{u}] = t) \in \Delta \textnormal{ and }
    |\bar{u}| = |\bar{t}|
  \end{array}
  \]
  \caption{Reduction with respect to definitions}
  \label{fig:sarred}
\end{figure}

Figure~\ref{fig:sarred} defines a reduction semantics for terms with
respect to a list $\Delta$ of definitions.  The notation $t \leadsto_\Delta t'$ means
that $t$ reduces to $t'$ possibly using the definitions in $\Delta$.  The rules are the same as in
Figure~\ref{fig:redsem} above, except that we add the last rule for
looking up a definition from $\Delta$.  


\begin{definition}
  A term $t$ is a value with respect to a list $\Delta$ of definitions iff $t$ contains no subterms of any of these forms:
  \begin{itemize}
  \item $(\lam{x}{t})\ t'$
  \item $\mathsf{R}\ \mathsf{Nil}\ t_1\ t_2$
  \item $\mathsf{R}\ (\mathsf{Cons}\ t_a\ t_b)\ t_1\ t_2$
  \item $\mathsf{f}[\bar{t}]$
  \end{itemize}
\end{definition}

The following should be proved in detail to establish the intended consequences of the above definitions.

\begin{proposition}[Safety]
  If $\textit{Wf}\ \Delta$ and $\Delta;\cdot\ |\ \cdot \textit{Closed}\ t$,
  then either there exists $t'$ such that $t \leadsto_\Delta t'$, or
  $t$ is a value.
\end{proposition}

\begin{proposition}[Normalization]
  If $\textit{Wf}\ \Delta$ and $\Delta;\cdot\ |\ \cdot \textit{Closed}\ t$,
  then there exists value $t'$ such that $t \leadsto_\Delta^* t'$.
\end{proposition}

\subsection{Questions}

\textbf{1. Could \sar use $\lambda$-encodings instead of a built-in
  recursor?}  The usual $\lambda$-encodings like the Church and
Parigot encodings represent data using non-linear $\lambda$-terms in
general.  The Scott encoding is affine, and even one can derive
recursion on it in untyped $\lambda$-calculus.  But that derivation,
which goes through the exotic Lepigre-Rafalli encoding, is
nonlinear~\cite[Section 7]{jenkins+21}.  So it seems that the only way
to use $\lambda$-encodings (and gain their benefits for keeping the
language design concise) would be to impose some additional discipline
that would allow non-affine terms but restrict them in some different
way to prevent divergence.  But it is unclear how that would work.

\section{Typing without termination}

In this section, we define Typed \sar, which is a typed version of the
\sar language just presented.  In Typed \sar, we write terms with some
type annotations.  This makes it possible to compute types for such
terms.  Erasing these annotations results in a term of \sar.  We may
then require both that a term is typable and that its erasure is
closed, in the sense of the previous section.  This ensures that the
term is typable and normalizing.  A simple argument then shows that
there is an uninhabited type, thus proving the theory consistent.  We
begin with the syntax of annotated terms, including types.

\subsection{Annotated terms}

The syntax of annotated terms for Typed \sar is shown in
Figure~\ref{fig:annotm}.  We add several groups of new notations.
\begin{itemize}
\item Constructs from pure dependent type theory:
  \begin{itemize}
  \item $\star$, the type for types;
  \item dependent function types $\Pia{x}{M}{M'}$;
  \item erased dependent function types $\allt{x}{M}{M'}$, which introduce a variable $x:M$ that
    may then be used in the body $M'$ without corresponding to an input to a function; and
  \item erased applications $\appe{M}{N}$, giving an instantiation to a $\forall$-bound variable.
  \end{itemize}
\item Constructs for typed extensional equality:
  \begin{itemize}
  \item $\rfl{M}$ a proof of reflexivity
  \item $\cng{x}{T}{M}{M'}$ a substitution principle, allowing to replace a term by an equal one in a type
  \item $\ext{M}$ an extensionality principle
  \item $\eqtm{M}{T}{M'}$ expressing that $M$ and $M'$ are equal at type $T$
  \end{itemize}
\item Additionally we have:
\begin{itemize}
\item annotations on $\lambda$-bound variables;
\item annotations on the parameters to $\bar{u}$ in definitions; and
\item the type $\mathsf{List}$ for lists.
\end{itemize}
\end{itemize}

\begin{figure}
  \[
  \begin{array}{llll}
    \textit{Constants} & C & ::= &  \mathsf{Nil}\ |\ \mathsf{Cons}\ |\ \mathsf{R}\ |\ \mathsf{List} \\
    \textit{Annotated terms} & M, N & ::= &
    x\ |\ u\ |\ C\ |\ \star\ |\ \mathbf{f}[\bar{M}]\ |\\
    \ &\ &\ & \tlam{x}{M}{N}\ |\ \Tlam{x}{M}{N}\ |\ M\ N\ |\ \appe{M}{N}\\
    \ &\ &\ & \Pia{x}{M}{N}\ |\ \allt{x}{M}{N}\ |\\    
    \ &\ &\ & \rfl{M}\ |\ \cng{x}{T}{M}{M'}\ |\ \ext{M}\ |\ \eqtm{M}{T}{M'} \\
    \textit{Annotated definitions} & D & ::= & \mathbf{f}[u_1:M_1,\cdots,u_k:M_k] = t \\
    \textit{Lists of definitions} & \Delta & ::= & \cdot \ |\ \Delta, D
  \end{array}
  \]
  \caption{Annotated terms of Typed \sar}
  \label{fig:annotm}
\end{figure}

\subsection{Typing rules}

The typing rules for Typed \sar are listed in several figures: rules
for pure dependent type theory with $\star : \star$ in
Figure~\ref{fig:sartpdep}, types for list constants in
Figure~\ref{fig:sartplist}, and rules for equality in
Figure~\ref{fig:sartpeq}.  The conversion rule, labeled $(c)$ in
Figure~\ref{fig:sartpdep}, references the erasure $|M|$ of terms $M$.
Erasure is defined in Figure~\ref{fig:erase}.  Its use in the
conversion rule is what makes this a Curry-style dependent type
theory, because terms are considered equal regardless of differences
in their annotations.  Erasure drops the equality proof from uses of
substitution ($\rho$-terms).  It also drops implicit arguments; i.e.,
$N$ in $\appe{M}{N}$.  Annotations on bound variables are also
dropped.  It otherwise proceeds homomorphically throughout terms.
Note that the erasure of a term might not be a schematic affine term
in the sense of Section~\ref{sec:sar}, both because the type system
does not enforce the affine property, and also because erasure might
not remove some constructs like $\Pi$-types from terms.  While
$\Pi$-types used as annotations would all be removed, such constructs
could also appear as arguments in terms.  Those occurrences would not
be removed by erasure.  If one wanted to enforce that conversion is
terminating, this point would have to be addressed, either by relaxing
the notion of affine to permit extra occurrences in constructs like
$\Pi$-types, or strengthening the notion of erasure to remove all such
constructs.  For now, we simply do not concern ourselves with
termination of conversion (as we also do not concern ourselves with
feasibility of conversion: terminating terms of \sar could still be
infeasible to normalize).  

Let us consider the constructs for equality, with typing rules in Figure~\ref{fig:sartpeq}, in more detail.

\begin{itemize}
\item The $\cng{x}{T}{M}{M'}$ construct is used with a proof $M$ that two terms $M_1$ and $M_2$ are
  equal at some type $T'$.  The $x.T$ part of the construct shows (by occurrence of bound variable $x$)
  which occurrences of $M_1$ are to
  be replaced with $M_2$ in the type of $M'$.  The rule requires that $T$ is typable assuming $x : T'$.
  This is to prevent applying an equality at type $T'$ to replace an occurrence of $M_1$ where that
  occurrence is being used at a different type (not $T'$).  Since this is Curry-style type theory,
  the same term could be used at different types, because identity of terms depends on their erasures only.
\item The $\ext{M}$ construct is for extensionality.  There are three different typing rules,
  for applying extensionality at $\Pi$-type, $\forall$-type, or the equality type itself.
\end{itemize}



\begin{figure}
\[
\begin{array}{lll}
  \infer{\Gamma\vdash x : M}{\Gamma(x) = M}
  &\ &
  \infer{\Gamma\vdash \tlam{x}{M}{N} : \Pia{x}{M}{N'}}{\Gamma,x:M\vdash N : N'}
  \\ \\
  \infer{\Gamma\vdash M\ N: [N/x]M'}{\Gamma\vdash M:\Pia{x}{N'}{M'} & \Gamma \vdash N:N'}
  &\ &
  \infer{\Gamma\vdash \Tlam{x}{M}{N} : \allt{x}{M}{N'}}{\Gamma,x:M\vdash N : N' & x\not\in\textit{FV}(|N|)}
  \\ \\
  \infer{\Gamma\vdash \appe{M}{N}: [N/x]M'}{\Gamma\vdash M:\allt{x}{N'}{M'} & \Gamma \vdash N:N'}
  &\ &
  \infer[(c)]{\Gamma \vdash M : N}{\Gamma \vdash M : N' & |N| =_{\beta,\eta} |N'| & \Gamma\vdash N:\star}
  \\ \\
    \infer{\Gamma \vdash \star : \star}{\ }
&\ &\ 
\end{array}
\]
\caption{Rules from pure dependent theory}
\label{fig:sartpdep}
\end{figure}

\begin{figure}
  \[
  \begin{array}{lll}
  \mathsf{Nil} & : & \allt{A}{\star}{\mathsf{List}\ A}
\\
\mathsf{Cons} & : & \allt{A}{\star}{A \to \mathsf{List}\ A \to \mathsf{List}\ A}
 \\
 \mathsf{List} & : & \star \to \star
 \\
 \mathsf{R} & : & \allt{A}{\star}{\allt{C}{\mathsf{List}\ A \to \star}{\ }} \\
   \ &\ &
   (\Pia{h}{A}{\Pia{t}{\mathsf{List}\ A}{C\ t \to C\ (\appe{\mathsf{Cons}}{A}\ h\ t)}}) \to \\
   \ &\ &  C\ (\appe{\mathsf{Nil}}{A}) \to \\
   \ &\ & \Pia{x}{\mathsf{List}\ A}{C\ x}
  \end{array}
  \]
\caption{Types for list constants}
\label{fig:sartplist}
  \end{figure}

\begin{figure}
  \[
  \begin{array}{lll}
  \infer{\Gamma \vdash \eqtm{N_1}{M}{N_2} : \star}{\begin{array}{l}\Gamma \vdash M : \star \\ \Gamma \vdash N_1 : M \\ \Gamma \vdash N_2 : M\end{array}}
  &\ &
  \infer{\Gamma \vdash \cng{x}{T}{M}{M'} : [M_2/x]T}
        {\begin{array}{l}\Gamma \vdash M : \eqtm{M_1}{T'}{M_2} \\ \Gamma , x : T' \vdash T : \hat{T} \\ \Gamma \vdash M' : [M_1/x]T
        \end{array}}
  \\ \\
     \infer{\Gamma \vdash \ext{M} : \eqtm{M_1}{(\Pia{x}{T}{T'})}{M_2}}{\Gamma \vdash M : \Pia{x}{T}{(\eqtm{M_1\ x}{T'}{M_2\ x})}}
    &\ &
          \infer{\Gamma \vdash \ext{M} : \eqtm{M_1}{(\eqtm{M_a}{T}{M_b})}{M_2}}
                {\begin{array}{l}\Gamma \vdash M_1 :\eqtm{M_a}{T}{M_b} \\ \Gamma \vdash M_2 : \eqtm{M_a}{T}{M_b} \end{array}}
\\ \\ 
     \infer{\Gamma \vdash \ext{M} : \eqtm{M_1}{(\allt{x}{T}{T'})}{M_2}}{\Gamma \vdash M : \allt{x}{T}{(\eqtm{M_1\ x}{T'}{M_2\ x})}}
    &\ & 
    \infer{\Gamma \vdash \rfl{M} : \eqtm{M}{T}{M}}{\Gamma \vdash M : T}

\end{array}
  \]
  \caption{Rules for equality}
  \label{fig:sartpeq}
  \end{figure}

\begin{figure}
  \[
  \begin{array}{lll}
    |C| & = & C \\
    |\star| & = & \star \\
    |\Pia{x}{M}{M'}| & = & \Pia{x}{|M|}{|M'|} \\
    |\allt{x}{M}{M'}| & = & \allt{x}{|M|}{|M'|} \\
    |x| & = & x \\
    |\appe{M}{N}| & = & |M| \\    
    |M\ N| & = & |M|\ |N| \\
    |\tlam{x}{M}{M'}| & = & \lam{x}{|M'|} \\
    |\Tlam{x}{M}{M'}| & = & |M'| \\
    |\eqtm{M_1}{M}{M_2}| & = & \eqtm{|M_1|}{|M|}{|M_2|}\\
    |\rfl{M}| & = & \rfl{|M|} \\
    |\cng{x}{T}{M}{M'}| & = & |M'| \\
    |\ext{M}| & = & \ext{|M|}
  \end{array}
  \]
  \caption{Erasing annotations}
  \label{fig:erase}
\end{figure}

\subsection{Examples}

In this section, we show examples that are permitted by the type
system and whose erasures satisfy the requirements of schematic affine
recursion.

\subsubsection{Basic datatypes}

Let us make the following simple definitions, to have some basic datatypes to use:
\[
\begin{array}{lllll}
  \textbf{False} & : & \star & := & \allt{X}{\star}{X} \\
  \textbf{Unit} & : & \star & := & \mathsf{List}\ \textbf{False} \\
  \textbf{Nat} & : & \star & := & \mathsf{List}\ \textbf{Unit}
\end{array}
\]
\noindent Now we may define some terms of these types. Notice that there is just one inhabitant of the \textbf{Unit} type
in a consistent context,
because we cannot apply $\appe{\mathsf{Cons}}{\textbf{False}}$ to build any other inhabitant than just $\appe{\mathsf{Nil}}{\textbf{False}}$:
\[
\begin{array}{lllll}
  \textbf{unit} & : & \textbf{Unit} & := & \appe{\mathsf{Nil}}{\textbf{False}} \\
  \textbf{zero} & : & \textbf{Nat} & := & \appe{\mathsf{Nil}}{\textbf{Unit}} \\
  \textbf{succ} & : & \textbf{Nat}\to\textbf{Nat} & := & \appe{\mathsf{Cons}}{\textbf{Unit}}\ \textbf{unit} \\
\end{array}
\]

\subsubsection{Type-level data structures}

Thanks to the $\star : \star$ axiom (Figure~\ref{fig:sartpdep}), we can form lists of types; for example:
\[
\appe{\mathsf{Cons}}{\star}\ \textbf{Unit}\ (\appe{\mathsf{Cons}}{\star}\ \textbf{Nat}\ (\appe{\mathsf{Nil}}{\star}))
\]

\subsubsection{A congruence principle}

As an example of equational reasoning, let us may derive this congruence principle:
\[
\begin{array}{lll}
\textbf{cong} & : & \allt{X}{\star}{\allt{Y}{\star}{\allt{f}{X \to Y}{\allt{x}{X}{\allt{x'}{X}{\ }}}}} \\
\ &\ &\ \ \ \eqtm{x}{X}{x'} \to \\
\ &\ &\ \ \ \eqtm{f\ x}{Y}{f\ x'}
\end{array}
\]
\noindent This states that if $x$ equals $x'$, then $f\ x$ equals $f\ x'$. The proof is 
\[
\begin{array}{l}
\Tlam{X}{\star}{\Tlam{Y}{\star}{\Tlam{f}{X \to Y}{\Tlam{x}{X}{\Tlam{x'}{X}{\ }}}}} \\
\ \ \ \tlam{p}{\eqtm{x}{X}{x'}}{\cng{y}{\eqtm{f\ x}{Y}{f\ y}}{p}{\rfl{(f\ x)}}}
\end{array}
\]
\noindent This works because:
\begin{itemize}
\item $\rfl{(f\ x)}$ has type $\eqtm{f\ x}{Y}{f\ x}$
\item then the $\rho$-term is saying that because $p$ proves $\eqtm{x}{X}{x'}$,
  we may replace the right occurrence of $x$ in $\eqtm{f\ x}{Y}{f\ x}$ (as derived by $\epsilon$) with $x'$.
  \end{itemize}

\subsubsection{Inductive reasoning}

Consider these definitions:
\[
\begin{array}{lllll}
  \textbf{id} & : & \allt{X}{\star}{\mathsf{List}\ X \to \mathsf{List}\ X} & := & \Tlam{X}{\star}{\tlam{x}{X}{x}} \\
  
  \textbf{rebuild} & : & \allt{X}{\star}{\mathsf{List}\ X \to \mathsf{List}\ X} & := & \Tlam{X}{\star}{\appe{\appe{\mathsf{R}}{X}}{\tlam{x}{\mathsf{List}\ X}{\mathsf{List}\ X}}\ (\appe{\mathsf{Cons}}{X})\ \appe{\mathsf{Nil}}{X}}
  \end{array}
\]
\noindent The \textbf{rebuild} function recursively applies
$\mathsf{Cons}$ to a list, starting from $\mathsf{Nil}$.  Notice that the instantiation of the variable $C$ in the type of $\mathsf{R}$ is
the constant constructor
\[
\tlam{x}{\mathsf{List}\ X}{\mathsf{List}\ X}
\]
\noindent We are using $\mathsf{R}$ for
(non-dependently typed) computation, and are just trying to compute a
$\mathsf{List}\ X$.

We can state that \textbf{rebuild} equals
\textbf{id}, using our extensional equality:
\[
\eqtm{\textbf{rebuild}}{(\allt{X}{\star}{\mathsf{List}\ X \to \mathsf{List}\ X})}{\textbf{id}}
\]
\noindent The proof of this is $\ext{\ext{\textbf{pf}}}$ where we have
this type and definition for the inductive $\textbf{pf}$, and helper
predicate, and writing $\alpha$ as a label, for subsequent reference:
\[
\begin{array}{lll}
  \textbf{pred} & : & \allt{X}{\star}{\mathsf{List}\ X \to \star} = \\
  \ & \multicolumn{2}{l}{\Tlam{X}{\star}{\tlam{x}{\mathsf{List}\ X}{\eqtm{\appe{\textbf{rebuild}}{X}\ x}{(\mathsf{List}\ X)}{\appe{\textbf{id}}{X}\ x}}}} \\ \\ 
  \textbf{pf} & : & \allt{X}{\star}{\Pia{x}{X}{\appe{\textbf{pred}}{X}\ x}} = \\
  \ & \multicolumn{2}{l}{\Tlam{X}{\star}{\tlam{x}{X}{\ }}} \\
  \ & \multicolumn{2}{l}{\ \ \ \appe{\appe{\mathsf{R}}{X}}{(\appe{\textbf{pred}}{X}\ x)}} \\
  \ & \multicolumn{2}{l}{\ \ \ \ \ {\ }^\alpha(\tlam{h}{X}{\tlam{t}{\mathsf{List}\ X}}{\tlam{\textit{ih}}{\appe{\textbf{pred}}{X}\ t}}} \\
  \ & \multicolumn{2}{l}{\ \ \ \ \ \ \ \ \ \appe{\appe{\textbf{cong}}{\mathsf{List}\ X}}{\mathsf{List}\ X}\ (\appe{\mathsf{Cons}}{X}\ h)\ \textit{ih})} \\
  \ & \multicolumn{2}{l}{\ \ \ \ \ \ \rfl{(\appe{\mathsf{Nil}}{X})}}
  \end{array}
\]
    \noindent The step case of the proof, labeled $\alpha$, uses
    congruence to go from a proof (namely \textit{ih}) of
    $\eqtm{\appe{\mathbf{rebuild}}{X}\ t}{\mathsf{List}\ X}{\appe{\mathbf{id}}{X}\ t}$,
    to a proof of the equality of those same terms except with
    $\appe{\mathsf{Cons}}{X}\ h$ applied to each.  Those terms are
    equal to the desired ones, where \textbf{rebuild} and \textbf{id}
    are applied outside \textsf{Cons} instead of inside, by
    conversion.


\bibliographystyle{plain} \bibliography{main}

\end{document}
