\documentclass{article}

\usepackage{amsmath,amssymb,amsthm}
\usepackage{url}
\usepackage{hyperref}
\usepackage{proof}
\usepackage{stmaryrd}
\usepackage{xspace}
\usepackage{parskip}
\usepackage{fullpage}
\usepackage{float}

\setlength{\topsep}{1em}

\begin{document}

\include{definitions}

\title{Type in Type and Schematic Affine Recursion}

\author{Aaron Stump and Victor Taelin}

\maketitle

\section{Terminating Computation First}

Constructive type theories based on the Curry-Howard isomorphism
enforce logical soundness by ensuring that all programs are uniformly
terminating.  Proofs are identified with programs, and diverging
programs would thus prove arbitrary propositions.  So these must be
ruled out statically.  The approach adopted in systems like Coq, Agda,
and Lean is to enforce termination through a combination of typing
and syntactic checks for structural decrease at recursive calls.

This paper proposes an alternative, where termination is enforced
through syntactic checks alone, prior to typing.  The approach has the
drawback that programs must be significantly restricted in order to
guarantee termination without any reference to types.  There is a
notable benefit, however: the type system is now no longer required to
enforce termination.  This greatly increases the options for the
typing relation, which now needs only to satisfy type safety, as
required in Programming Languages.

We present a language \sar, which combines an untyped affine lambda
calculus with a form of structural recursion.  With no further
restriction, this language allows diverging terms.  So we impose what
Alves et al. call the ``closed-by-construction'' restriction on
structural recursion~\cite{alves10}, found also in~\cite{dallago09}.
This requires that the functions to be iterated when recursing are
closed.  But this rules out most of the usual higher-order functions
like \texttt{map} on lists, where the function to iterate calls a
function $f$ that is given as a variable bound outside the recursion.
We address this problem by proposing a language of schematic terms,
where such variables $f$ are not $\lambda$-bound, but treated
schematically.  This allows generic definition of functions like
\texttt{map}, without losing termination.

With termination of \sar established prior to typing, we are free to
adopt a more exotic type system than possible in other constructive
type theories, where the burden of termination falls on typing.  To
demonstrate this, we consider a dependent type system called Typed
\sar, with the $\star : \star$ principle.

\section{Previous work on termination with affine recursion}
\label{sec:prevaff}

Affine lambda calculus restricts $\lambda$-abstractions so that the
$\lambda$-bound variable may occur at most once in the body of the
abstraction.  With this restriction, $\beta$-reduction is easily seen
to be terminating, as the number of applications decreases by at least
one with every $\beta$-step.

\begin{figure}
  \[
  \begin{array}{llll}
    \textit{Terms} & t & ::= & x\ |\ \lam{x}{t}\ |\ t\ t'\ |\ \mathsf{Nil}\ |\ \mathsf{Cons}\ t_1\ t_2\ |\ \mathsf{R}\ t_1\ t_2\ t_3
  \end{array}
  \]
  \caption{The syntax of untyped terms}
\label{fig:syn}
\end{figure}

But affine lambda calculus seems too restrictive for regular
programming.  For example, Church-encoded data such as natural numbers
and lists are not affine in general.  So we consider expanding the
language with some form of inductive datatype, and its structural
recursor.  For simplicity, in this paper we just consider a datatype of lists, with its
recursor.  The syntax is shown in Figure~\ref{fig:syn}, and its reduction semantics in Figure~\ref{fig:redsem}.

\begin{figure}
  \[
  \begin{array}{lll}
    (\lam{x}{t})\ t' & \leadsto & [t'/x]t \\
    \mathsf{R}\ \mathsf{Nil}\ t_1\ t_2 & \leadsto & t_2 \\
    \mathsf{R}\ (\mathsf{Cons}\ t_a\ t_b)\ t_1\ t_2 & \leadsto & t_1\ t_a\ t_b\ (\mathsf{R}\ t_b\ t_1\ t_2)
  \end{array}
  \]
  \caption{Reduction semantics}
\label{fig:redsem}
\end{figure}

\noindent Without some further restriction, this language is
easily seen to allow diverging terms.  Let us see an example, adapted
from~\cite{alves10}.  Define
\begin{eqnarray*}
  \texttt{app}_t & = & \lam{y}{y\ t} \\
  \texttt{apply} & = & \lam{a}{\lam{b}{a\ b}} \\
\end{eqnarray*}
\noindent where $\texttt{app}_t$ is schematic in meta-variable $t$. Then we have this reduction sequence, for any term $t$:
\[
\begin{array}{ll}
  \texttt{app}_t\ (\texttt{app}_t\ \texttt{apply}) & \leadsto^2 \\
  \texttt{app}_t\ (\lam{b}{t\ b}) & \leadsto^2 \\
  t\ t& \
  \end{array}
\]
\noindent The example is easier to complete with an iterator, defined as
\[
\texttt{It} = \lam{n}{\lam{f}{\lam{x}{\mathsf{R}\ n\ (\lam{q}{\lam{r}{f}})\ x}}}
\]
\noindent This uses \textsf{R} to repeat the function $f$, but dropping the head
and tail of the list that \textsf{R} supplies to its second argument in case the first is a \textsf{Cons}.  Using \texttt{It}, define
\begin{eqnarray*}
\texttt{u} & = & \lam{x}{x} \\
\texttt{T} & = & \mathsf{Cons}\ u\ (\mathsf{Cons}\ u\ \mathsf{Nil}) \\
\delta & = & \lam{x}{\texttt{It}\ \texttt{T}\ \texttt{app}_x\ \texttt{apply}}
\end{eqnarray*}

\noindent \texttt{T} is a list of length two, and applying \texttt{It} with it
will lead to two nested calls.  So we have
\[
\begin{array}{ll}
  \texttt{It}\ s\ \texttt{app}_x\ \texttt{apply} & \leadsto^+ \\
  \texttt{app}_x\ (\texttt{app}_x\ \texttt{apply}) & \leadsto^+ \\
  x\ x& \
\end{array}
\]
\noindent So the term $\Omega = \delta\ \delta$ is not normalizing, 
because $\delta$ reduces to $\lam{x}{x\ x}$.

This example is not so surprising, since the reduction rule for
\textsf{R} is (at the meta-level) not affine.  What is more surprising
is that the example still is diverging if one adopts what Alves et al.
call the ``closed at reduction'' restriction on the reduction
rules for \textsf{R}:
  \[
  \begin{array}{lllll}
    \mathsf{R}\ \mathsf{Nil}\ t_1\ t_2 & \leadsto & t_2, & \textnormal{if } \textit{FV}(t_1) = \emptyset\\
    \mathsf{R}\ (\mathsf{Cons}\ t_a\ t_b)\ t_1\ t_2 & \leadsto & t_1\ t_a\ t_b\ (\mathsf{R}\ t_b\ t_1\ t_2),& \textnormal{if } \textit{FV}(t_1) = \emptyset
  \end{array}
  \]
\noindent With the ``closed at reduction'' restriction, the former
reduction sequence is not available.  But we still have this one:
\[
\begin{array}{ll}
  \delta\ \delta & \leadsto \\
  \texttt{It}\ \texttt{T}\ \texttt{app}_\delta\ \texttt{apply} & \leadsto^+ \\
  \texttt{app}_\delta\ (\texttt{app}_\delta\ \texttt{apply}) & \leadsto^+ \\
  \delta\ \delta& \
\end{array}
\]
\noindent showing that $\Omega$ diverges.

Alves et al. observe that if one goes even further and restricts the
syntax so that $\mathsf{R}\ t\ t_1\ t_2$ is only syntactically allowed
if $t_1$ is closed, then the language is indeed terminating.  They
call this the ``closed at construction'' restriction.  It
significantly reduces the computational power of the language: only
the primitive recursive functions are definable~\cite{alves10}.

While limiting oneself to primitive recursive functions may be a
concern for theoretical applications, it is not a concern for
practical programming, where the primitive recursive functions already
encompass computations far beyond the feasible.  But ``closed at construction''
does have a serious practical drawback: it prevents the usual higher-order
combinators one expects in functional programming.  For example, using the
unrestricted syntax, we may define a \texttt{map} function on lists:
\[
\texttt{map} = \lam{f}{\lam{x}{\mathsf{R}\ x\ (\lam{h}{\lam{t}{\lam{r}{\mathsf{Cons}\ (f\ h)\ r}}})\ \mathsf{Nil}}}
\]
\noindent Here, \textsf{R} is used to recurse through list $x$,
applying $f$ to the head $h$ of each sublist.  But the term performing
that application has $f$ free.  So this program, along with many
others from usual functional programming practice, will be disallowed
by affine lambda calculus with ``closed at construction'' recursion.

\section{Schematic affine recursion}

We can address this difficulty by applying a basic idea that one finds
in both Logic and Programming Languages, namely the use of schematic
constructions.  For the definition of Peano Arithmetic in first-order
logic, one postulates a \emph{scheme} of induction.  This is a
meta-level formulation representing an infinite set of axioms, each
one expressing the induction principle for proving $\all{x}{\phi}$
from base and step cases.  This is in contrast to second-order logic,
where a single axiom suffices, by quantifying, within the logic, over
the formula $\phi$.  In contrast, the first-order scheme of induction
is a meta-level quantification, outside the logic, over $\phi$.

We can use this same method here to recover generic programming while
respecting the ``closed at construction'' requirement.  We extend the
syntax of Figure~\ref{fig:syn} to allow top-level schematic
definitions of terms.  This is shown in Figure~\ref{fig:sarsyn}.
Schematic terms have the same syntax as terms above, except
for the addition of the construct $\mathbf{f}[\bar{t}]$.  Here,
$\bar{t}$ is a (finite) vector of schematic terms, and $\mathbf{f}$ is
a defined symbol.  Figure~\ref{fig:sarwf} defines a relation $\textit{Wf}$
on lists of definitions, imposing these requirements:
\begin{itemize}
\item The defined symbols occurring on the right-hand side of a definition
  are defined earlier in the list, with
  the same number of schematic variables $\bar{u}$ as the arguments $\bar{t}$
  where that symbol is applied.
\item In applications $\mathbf{f}[\bar{t}]$, the terms $\bar{t}$ are
  all required to be closed, which means that they have no free variables
  except for schematic ones.  Those will only be instantiated by closed
  terms, so they may stand for such in applications of defined symbols.
\item The term $t_1$ in a recursion $\mathsf{R}\ t_1\ t_2\ t_3$ is
  required to be closed.
  \end{itemize}
These requirements are imposed using the following relations:
\begin{itemize}
\item $\textit{Wf}\ \Delta$ expresses that the list $\Delta$ of
  schematic definitions is well-formed, in the sense that
each definition in $\Delta$ is well-formed with respect to the definitions
to the left of it in $\Delta$.
\item The relation $\Delta \vdash \textit{Wf}\ D$ expresses
  that definition $D$ is well-formed with respect to $\Delta$.  This requires, for definition
  $\mathbf{f}[\bar{u}] = t$, that the body $t$ of the
  definition is closed with respect to the parameters $\bar{u}$, and
  (for simplicity) that $\mathbf{f}$ is not declared already in $\Delta$.
\item The relation $\Delta; \bar{u}\ |\ \bar{x} \vdash
  \textit{Closed}\ t$ means that term $t$ is closed with respect to
  the definitions in $\Delta$ (which are just used to check that
  defined symbols $\mathbf{f}$ are applied to the correct number of
  arguments), and the parameters $\bar{u}$.  The parameters are
  considered closed themselves, as are the locally bound variables
  $\bar{x}$.  Those variables are dropped, however, in premises
  (of the rules of Figure~\ref{fig:sarwf}) where
  terms must not contain any free local variables.  Dropping them
  enforces that the terms in question cannot contain free local variables.
  This can be seen
  where $\bar{x}$ is replaced with $\cdot$ in premises to the rules
  expressing closedness of $\mathsf{R}$-terms and applications
  $\mathbf{f}[\bar{t}]$ of defined symbols.
\end{itemize}

\begin{figure}
  \[
  \begin{array}{llll}
   \textit{Defined symbols} & \mathbf{f} & \ &\ \\
   \textit{Schematic variables} & u & \ &\ \\
    \textit{Schematic terms} & t & ::= & x\ |\ u\ |\ \mathbf{f}[\bar{t}]\ |\ \lam{x}{t}\ |\ t\ t'\ |\\
    \ &\ &\ & \mathsf{Nil}\ |\ \mathsf{Cons}\ t_1\ t_2\ |\ \mathsf{R}\ t_1\ t_2\ t_3 \\
    \textit{Definitions} & D & ::= & \mathbf{f}[\bar{u}] = t \\
    \textit{Lists of definitions} & \Delta & ::= & \cdot \ |\ \Delta, D
  \end{array}
  \]
  \caption{Syntax of \sar}
\label{fig:sarsyn}
\end{figure}

\begin{figure}
  \[
  \begin{array}{lll}
    \infer{\textit{Wf}\ \cdot}{\ } &
    \infer{\textit{Wf}\ (\Delta,\ D)}{\textit{Wf}\ \Delta & \Delta \vdash \textit{Wf}\ D}
    &\
    \\ \\
    \infer{\Delta\vdash\textit{Wf}\ \ \mathbf{f}[\bar{u}] = t}
          {\begin{array}{l}
              \Delta; \bar{u}\ |\ \cdot \vdash\textit{Closed}\ t\\
          \all{\bar{u}'}{\all{t'}{(\mathbf{f}[\bar{u}'] = t')\not\in \Delta}} \end{array}} &
    \infer{\Delta; \bar{u}\ |\ \bar{x} \vdash\textit{Closed}\ u }{u \in \{\bar{u}\}} &
    \infer{\Delta; \bar{u}\ |\ \bar{x} \vdash\textit{Closed}\ x }{x \in \{\bar{x}\}} 
  \\ \\           
  \infer{\Delta;\bar{u}\ |\ \bar{x} \vdash\textit{Closed}\ \lam{y}{t}}{\Delta;\bar{u}\ |\ \bar{x},y \vdash\textit{Closed}\ t} &
  \infer{\Delta;\bar{u}\ |\ \bar{x} \vdash\textit{Closed}\ (t_1\ t_2)}{\begin{array}{l}\Delta;\bar{u}\ |\ \bar{x} \vdash\textit{Closed}\ t_1\\
                                                                                       \Delta;\bar{u}\ |\ \bar{x} \vdash\textit{Closed}\ t_2
                                                                       \end{array}} &
  \infer{\Delta;\bar{u}\ |\ \bar{x} \vdash\textit{Closed}\ \mathsf{Nil}}{\ }
  \\ \\
  \infer{\Delta;\bar{u}\ |\ \bar{x} \vdash\textit{Closed}\ \mathsf{Cons}\ t_1\ t_2}
         {\begin{array}{l}\Delta;\bar{u}\ |\ \bar{x} \vdash\textit{Closed}\ t_1\\
                          \Delta;\bar{u}\ |\ \bar{x} \vdash\textit{Closed}\ t_2
         \end{array}} &
  \infer{\Delta;\bar{u}\ |\ \bar{x} \vdash \textit{Closed}\ \mathsf{R}\ t_1\ t_2\ t}
        {\begin{array}{l}
         \Delta;\bar{u}\ |\ \cdot \vdash\textit{Closed}\ t_1\\
         \Delta;\bar{u}\ |\ \bar{x} \vdash\textit{Closed}\ t_2\\
         \Delta;\bar{u}\ |\ \bar{x} \vdash\textit{Closed}\ t
         \end{array}}
   &\infer{\Delta;\bar{u}\ |\ \bar{x}\vdash\textit{Closed}\ \mathbf{f}[\bar{t}]}
        {\begin{array}{l}
             (\mathbf{f}[\bar{u}] = t) \in \Delta \\
            |\bar{u}| = |\bar{t}| \\
           \Delta;\bar{u}\ |\ \cdot \vdash \textit{Closed}\ \bar{t}
         \end{array}} 
\\ \\
\infer{\Delta;\bar{u}\ |\ \bar{x}\vdash \textit{Closed}\ \cdot}{\ }&
\infer{\Delta;\bar{u}\ |\ \bar{x}\vdash \textit{Closed}\ (t,\bar{t})}
  {\begin{array}{l}
    \Delta;\bar{u}\ |\ \bar{x}\vdash \textit{Closed}\ t \\
    \Delta;\bar{u}\ |\ \bar{x}\vdash \textit{Closed}\ \bar{t}
\end{array}}&\ 
   \end{array}
  \]
  \caption{Well-formedness of definitions and lists of definitions; closed schematic terms and lists of such terms}
\label{fig:sarwf}
\end{figure}

\subsection{Example}

We may define higher-order functions like \texttt{map} using a schematic definition:
\[
\texttt{map}[f] = \lam{x}{\mathsf{R}\ x\ (\lam{h}{\lam{t}{\lam{r}{\mathsf{Cons}\ (f\ h)\ r}}})\ \mathsf{Nil}}
\]
\noindent Call this definition $D_{\texttt{map}}$.  We have $\textit{Wf}\ D_{\texttt{map}}$, because the
body of the definition, namely
\[
\mathsf{R}\ x\ (\lam{h}{\lam{t}{\lam{r}{\mathsf{Cons}\ (f\ h)\ r}}})\ \mathsf{Nil}
\]
\noindent is closed with respect the parameter $f$.  Being closed
means that the term iterated by \textsf{R} should have no free
variables.  Here, this is the term beginning $\lambda\, h$.  It may,
however, use the parameter $f$, as indeed it does.

It is possible to define the problematic term $\delta$ from
Section~\ref{sec:prevaff} above, as a schematic term.  We first
must define $\mathbf{It}$ schematically:
\[
\mathbf{It}[f] = \lam{n}{\lam{x}{\mathsf{R}\ n\ (\lam{q}{\lam{r}{f}})\ x}}
\]
\noindent This is necessary so that the second argument to $\mathsf{R}$ will
be closed except for parameters (here, \textit{f}).  Note that this definition
reverses the order of the first two arguments to \textbf{It}, compared to the definition
in Section~\ref{sec:prevaff}.  Now using $\mathbf{It}$,
we can define $\delta$ schematically, where $\mathbf{T}$ is, as above, a list of length two:
\[
\begin{array}{lll}
\mathbf{u} & = & \lam{x}{x} \\
  \mathbf{T} & = & \mathsf{Cons}\ \mathbf{u}\ (\mathsf{Cons}\ \mathbf{u}\ \mathsf{Nil}) \\
  \delta[u] & = & \mathbf{It}[\texttt{app}_u]\ \mathbf{T}\ \texttt{apply}
\end{array}
\]
\noindent This is a well-formed definition, because the argument supplied for
the parameter of $\mathbf{It}$ is closed with respect to parameter $u$.

So we could define $\mathbf{It}$ and $\delta$.  What breaks down is
the definition of $\Omega$.  Here, as $\delta$ is a schematic term, it
must be supplied with a closed term.  We cannot write $\delta[\delta]$
because $\delta$ cannot be used as an argument: it is not a closed
term, but requires a closed term as an argument for its parameter.
This shows that restricting terms to be closed with respect to
schematic definitions blocks the counterexample above to termination.

\subsection{Reduction}

\begin{figure}
  \[
  \begin{array}{llll}
    (\lam{x}{t})\ t' & \leadsto_\Delta & [t'/x]t &\ \\
    \mathsf{R}\ \mathsf{Nil}\ t_1\ t_2 & \leadsto_\Delta & t_2 &\ \\
    \mathsf{R}\ (\mathsf{Cons}\ t_a\ t_b)\ t_1\ t_2 & \leadsto_\Delta & t_1\ t_a\ t_b\ (\mathsf{R}\ t_b\ t_1\ t_2) &\ \\
    \mathsf{f}[\bar{t}] & \leadsto_\Delta & [\bar{t}/\bar{u}]t & \textnormal{if }(\mathsf{f}[\bar{u}] = t) \in \Delta \textnormal{ and }
    |\bar{u}| = |\bar{t}|
  \end{array}
  \]
  \caption{Reduction with respect to definitions}
  \label{fig:sarred}
\end{figure}

Figure~\ref{fig:sarred} defines a reduction semantics for terms with
respect to a list $\Delta$ of definitions.  The notation $t \leadsto_\Delta t'$ means
that $t$ reduces to $t'$ possibly using the definitions in $\Delta$.  The rules are the same as in
Figure~\ref{fig:redsem} above, except that we add the last rule for
looking up a definition from $\Delta$.  


\begin{definition}
  A term $t$ is a value with respect to a list $\Delta$ of definitions iff $t$ contains no subterms of any of these forms:
  \begin{itemize}
  \item $(\lam{x}{t})\ t'$
  \item $\mathsf{R}\ \mathsf{Nil}\ t_1\ t_2$
  \item $\mathsf{R}\ (\mathsf{Cons}\ t_a\ t_b)\ t_1\ t_2$
  \item $\mathsf{f}[\bar{t}]$
  \end{itemize}
\end{definition}

The following should be proved in detail to establish the intended consequences of the above definitions.

\begin{proposition}[Safety]
  If $\textit{Wf}\ \Delta$ and $\Delta;\cdot\ |\ \cdot \textit{Closed}\ t$,
  then either there exists $t'$ such that $t \leadsto_\Delta t'$, or
  $t$ is a value.
\end{proposition}

\begin{proposition}[Normalization]
  If $\textit{Wf}\ \Delta$ and $\Delta;\cdot\ |\ \cdot \textit{Closed}\ t$,
  then there exists value $t'$ such that $t \leadsto_\Delta^* t'$.
\end{proposition}

\section{Typing without termination}

In this section, we define Typed \sar, which is a typed version of the
\sar language just presented.  In Typed \sar, we write terms with some
type annotations.  This makes it possible to compute types for such terms.
Erasing these annotations results in a term of \sar.  We may then require
both that a term is typable and that its erasure is closed, in the sense
of the previous section.  This ensures that the term is typable and
normalizing.  A simple argument then shows that there is an uninhabited
type, thus proving the theory consistent.

We take a somewhat unconventional view of typing, as a form of
abstraction.  A type for a term $M$ is some other term $N$ where some
information has been (deliberately) dropped.  The language features one
basic abstraction, namely that lists storing values that can be abstracted to $A$
can themselves be abstracted to $\mathsf{List}\ A$.

We begin with the syntax
of annotated terms, including types.

\subsection{Annotated terms}

The syntax of annotated terms for Typed \sar is shown in
Figure~\ref{fig:annotm}. The additions to the syntax
are:
\begin{itemize}
\item an annotation on $\lambda$-bound variables;
\item a form $\Tlam{x}{A}{B}$ of erased abstraction (where $x$ should not occur free in the erasure of $B$);
\item the type $\mathsf{List}$ for lists, giving us a basic abstraction; 
\item an annotation $\selfa{M}$ indicating that $M$ should be abstracted to itself; 
\item sort $\star$, for a most abstract entity; 
\item an annotation $\absta{M}$ indicating that $M$ should be abstracted to $\star$; and
 \item annotations on the parameters to $\bar{u}$ in definitions.
\end{itemize}
\noindent We will view types as abstractions of terms, and hence
reuse $\lambda$-abstraction to represent an abstraction of a function, as opposed
to introducing a new binder $\Pi$ for this.  The idea of using just one binder
for functions and their abstractions has been
studied previously by Kamareddine~\cite{kamareddine05}.  The typing relation
should be viewed as an abstraction relation: the proposition $M : N$ will mean that
$N$ is an abstraction of $M$.  It has discarded some information from $M$.  Annotations
on $\lambda$-bound variables are there to show which abstraction should be required
for the argument to the function.

\begin{figure}
  \[
  \begin{array}{llll}
    \textit{Annotated terms} & M, N & ::= &
    x\ |\ u\ |\ \mathbf{f}[\bar{M}]\ |\ \tlam{x}{M}{N}\ |\ \Tlam{x}{M}{N}\ |\ M\ N\ |\\
    \ &\ &\ & \mathsf{Nil}\ |\ \mathsf{Cons}\ M\ N\ |\ \mathsf{R}\ M_1\ M_2\ N\ |\ \mathsf{List}\ M\ |\\
    \ &\ &\ & \sigma\ M\ |\ \star
    \textit{Annotated definitions} & D & ::= & \mathbf{f}[u_1:M_1,\cdots,u_k:M_k] = t \\
    \textit{Lists of definitions} & \Delta & ::= & \cdot \ |\ \Delta, D
  \end{array}
  \]
  \caption{Annotated terms of Typed \sar}
  \label{fig:annotm}
\end{figure}

To develop an example, let us first recall that we can view natural numbers as lists with trivial data.
Let us write $A \to B$ instead
of $\tlam{x}{A}{B}$ when $x\not\in\textit{FV}(B)$.  So we may define:
\[
\begin{array}{lll}
  \mathbf{u} & = & \Tlam{A}{\star}{A \to A} \\
  \mathbf{Zero} & = & \mathsf{Nil} \\
  \mathbf{Suc} & = & \mathsf{Cons}\ \mathbf{u}
\end{array}
\]
\noindent Then
we may define the length function on lists as a function which simply discards any data in the list:
\[
\mathbf{length} = \Tlam{A}{\star}{\mathbf{map}\ (\tlam{h}{A}{\mathbf{u}})}
\]
\noindent Let us define the type \texttt{Nat} of natural numbers:
\[
\mathbf{Nat} = \mathsf{List}\ \mathbf{u}
\]
\noindent The type we intend to compute for an annotated version of \textbf{length} is the following:
\[
\Tlam{A}{\star}{\mathsf{List}\ A \to \texttt{Nat}}
\]
\noindent This function takes in a type $A$ in erased fashion, and
returns a function taking in an input of type $\mathsf{List}\ A$ and
returning \texttt{Nat}.  Such a function is abstract, as the return
value is always just \texttt{Nat} for every input, rather than some
particular (represented) natural number.

\subsection{Abstraction rules}

Figure~\ref{fig:abstr} gives the abstraction rules for Typed \sar.  

\begin{figure}
\[
\begin{array}{lll}
  \infer{\Gamma\vdash x : M}{\Gamma(x) = M}
  &\ &
  \infer{\Gamma\vdash \selfa{M} : M}{\ }
  \\ \\
  \infer{\Gamma\vdash \tau M : \star}{\ }
  &\ &
  \infer{\Gamma\vdash \tlam{x}{M}{N} : \tlam{x}{M}{N'}}{\Gamma\vdash N : N'}
  \\ \\
  \infer{\Gamma\vdash M\ N: M'\ N'}{\Gamma\vdash M:M' & \Gamma \vdash N:N'}
  &\ &
  \infer{\Gamma\vdash \Tlam{x}{M}{N} : \Tlam{x}{M}{N'}}{\Gamma\vdash N : N' & x\not\in\textit{FV}(|N|)}
  \\ \\
%  \infer{\Gamma\vdash M\ -N: M'\ -N'}{\Gamma\vdash M:M' & \Gamma \vdash N:N'}
\ 
  &\ &
  \infer{\Gamma\vdash \mathsf{Nil} : \mathsf{List}\ M}{\ }
\\ \\
  \infer{\Gamma \vdash M : N}{\Gamma \vdash M : N' & N =_{\beta,\eta} N'}
  &\ &
  \infer{\Gamma\vdash \mathsf{Cons} : \Tlam{A}{\star}{A \to \mathsf{List}\ A \to \mathsf{List}\ A}}{\ }
\end{array}
\]
\caption{Abstraction rules for Typed \sar}
\label{fig:abstr}
\end{figure}

\subsection{Examples}

\subsubsection{The length function}

Let us confirm that \textbf{length} has the desired type.  The annotated version from above is
\[
\mathbf{length} = \Tlam{A}{\star}{\mathbf{map}\ (\tlam{h}{A}{\mathbf{u}})}
\]
\noindent Its intended type is
\[
\Tlam{A}{\star}{\mathsf{List}\ A \to \texttt{Nat}}
\]
\noindent Using the 

\bibliographystyle{plain} \bibliography{main}

\end{document}
