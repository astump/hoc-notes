\documentclass{article}

\usepackage{amsmath,amssymb,amsthm}
\usepackage{url}
\usepackage{hyperref}
\usepackage{proof}
\usepackage{stmaryrd}
%\usepackage{MnSymbol}
\usepackage{parskip}
\usepackage{fullpage}
\usepackage{mathpartir}
\usepackage{subcaption}
\usepackage{float}


\begin{document}

\include{definitions}

\title{System Q: Logical Soundness with Logically Unsound Types}

\author{Aaron Stump and Victor Taelin}

\maketitle

\section{What is a type theory?}

A type theory is a statically typed programming language that can be
understood as a logic.  Programs are viewed as proofs, and the types
of programs are viewed as the formulas they prove.  This famous idea
is called the Curry-Howard isomorphism.  A very simple example is the
program $\lam{x}{\lam{y}{x}}$, which takes in input $x$ and then input
$y$, and returns $x$.  This program can be given the type $A \to B \to
A$, for any types $A$ and $B$.  That type expresses that the program
takes in an input of type $A$ and then one of type $B$, and returns a
result of type $A$.  That indeed correctly describes the behavior of
$\lam{x}{\lam{y}{x}}$.  But it is also a valid logical formula, where
the $\to$ operator is implication: $A$ implies $B$ implies $A$ for the
trivial reason that $A$ implies $A$, and adding an extra assumption
that $B$ is true does not change that fact.  To go beyond just
propositional logic, type theories use more expressive types than just
implications.  We will see examples below.

To be interpreted as a logic, it is not enough to have a way
to view the types of a programming language as formulas.  We must
ensure that it is not possible to prove false formulas.  So the
language must be logically sound.  In type theory, an essential part
of ensuring logical soundness is to guarantee that all programs
terminate.  The reason for this is that an infinite loop can be
viewed, in most programming languages, as having any type one wants.
So you can prove the formula \textsf{False} by writing a diverging
program.

Much theoretical effort has been expended on techniques for proving
logical soundness of type theories, by showing that all programs
are guaranteed to terminate.  

\section{A new approach to logical soundness}

There are two current traditions for devising type theories, that
should be mentioned for comparison:

\begin{enumerate}
\item \textbf{Church-style} type theory builds up a notion of typed
  terms (programs), where the types are inherent to those terms.  By a
  difficult argument, one shows that all well-typed programs
  terminate.  So the type system is enforcing termination, in addition
  to other properties usually enforced by static typing.  From
  termination, it is then easy to argue that the system is logically
  sound.  This is because it is relatively easy to show that values,
  which are the final results of computation, cannot have type False.

\item \textbf{Curry-style} type theory starts with a notion of
  type-free program, and then adds types to describe properties of the
  behavior of programs.  For example, the identity function can be
  described as having type $X \to X$ for any type $X$, as it is
  guaranteed to take an input of type $X$ and return an output of type
  $X$ (namely, the input it was given).  A difficult argument is still
  required to show that typing enforces termination.  But the language
  design is made quite a bit easier by not having types be inherent
  parts of programs.  This is because in reasoning about programs,
  one does not then have to reason about types inside them.  Programs
  are type-free, and typing comes second.  In fact, the slogan I propose
  for this style of type theory is ``Computation First'' (because we
  first explain what type-free programs are and how they execute, and
  only afterwards use types to describe their properties).  Krivine puts it simply: ``types can
  be thought of as properties of $\lambda$-terms''~\cite[page 43]{krivine93}.
\end{enumerate}

The philosophy we adopt here can be viewed as a strengthened form of
Curry-style type theory, with the modified slogan: ``Terminating
Computation First''.  The idea is similar to Curry-style type theory,
where one first defines type-free programs, and how they compute.  But
differently, these programs are designed so that they are guaranteed
to terminate, without reference to any notion of typing.  Just the
structure of the programs and the rules for how they execute are
sufficient to establish that all programs terminate.  Giving a
detailed proof of that fact is still not trivial, but expected to be
much simpler than the approaches based on typing.  And then one has a
lot of freedom to design a type system on top of the terminating
type-free language.  The only requirement is that the language should
have the usual type-safety property that one expects of any
statically typed programming language. This is vastly easier to
achieve than crafting a type system that enforces termination.  It
also opens the door to making use of exotic typing features that might
not enforce termination.  Since termination is enforced already from
the structure of untyped terms, we are free to adopt such types
without losing logical soundness.

This paper gives a particular example of this approach, in the form of
a type theory called Q.  The untyped substrate of the theory is based
on affine lambda calculus plus an affine-compatible form of
W-structures (the untyped components of W-types).  There are two other
design goals we pursue in this particular design: minimality and very
expressive typing.  We aim to have a core language with a small number
of primitive operations, and similarly for the type system.
Furthermore, to demonstrate the power of the approach, we include the
principle known as ``Type : Type'', which renders the type system very
expressive, but is usually avoided because it does not enforce
termination.  We emphasize that in our setting, the type system does
not need to do that, because termination for the underlying language
is ensured prior to typing.

\section{The untyped language of Q}

The syntax of Q's untyped programming language is shown in
Figure~\ref{fig:pl}.  Atomic terms are either variables $x$ or labels
$l$.  Labels will be used to distinguish between different kinds of
data.  Terms can also be anonymous functions $\lam{x}{s}$, with the
restriction that $x$ may be used at most once in $s$.  Such
$\lambda$-abstractions are called \emph{affine}.  Some restriction is
needed, or else it is very easy to write diverging $\lambda$-terms.
Traditionally, type theories have restricted anonymous functions using
types.  Requiring $\lambda$-abstractions to be affine is a well-known
if seldom used alternative.

Returning to the syntax: we have applications $t\ t'$ of a term $t$
being used as a function to term $t'$ given as the argument to that
function.  We have a trivial piece of data $\wunit$, which is useful
as a placehold.  We have a way to form structured data
$\ctor{l}{n}{r}$, and a term $\wrec{r}{t}$ for recursing over such
data.  These constructs constitute the untyped components of a version
of what is known as W-types, and they will be presented in detail
below.  Finally, there is a label-matching function $\{ l_1 \mapsto
t_1\ ;\ \ldots\ ;\ l_k\mapsto t_k \}$, which will return term $t_i$ if
applied to label $l_i$.


\begin{figure}
  \[
  \begin{array}{llll}
    \textit{Variables}  & x,y,z,\ldots & \ &\ \\
    \textit{Labels}  & l & \ &\ \\ 
    \textit{Terms} & s,r,t & ::= & x\ |\ i\ |\ l\ |\ \lam{x}{s}\ |\ t\ t'\ |\ \wunit\ |\ \ctor{l}{n}{r}\ |\ \wrec{r}{t} \\
    \ &\ &\ & \{ l_1 \mapsto t_1\ ;\ \ldots\ ;\ l_k\mapsto t_k \}
  \end{array}
\]
\caption{The syntax of Q's untyped language.  In $\lambda$-abstractions, the variable $x$ is allowed
  to occur at most once in the body $s$}
\label{fig:pl}
\end{figure}

\section{Typed Q}

Having considered the untyped language for Q, we now consider typing.  The approach we describe
is a form of Curry-style typing, and so the essential matter is to describe types and which
untyped terms have which types.  But we present the typing relation on annotated terms, so
that there is a clear path to implementing the theory.  Without annotations, deciding if a
given term has a given type is undecidable, as the type theory subsumes System F~\cite{wells99}.
But the annotations can all be erased, resulting in an untyped term in the syntax of Figure~\ref{fig:pl}.

The syntax of types is in Figure~\ref{fig:tp}, the typing rules are in Figure~\ref{fig:typing}, and erasure
is defined in Figure~\ref{fig:erase}.  To keep notation simpler with labels, typing assumes a label context
$\mathcal{L}$, which is a partition (i.e., set of disjoint sets $L_i$) of a finite set of labels.  Each disjoint
set $L_i$ serves as an association of labels, so that when a term contains label $l \in L_i$, we assign
the type $\{l_1,\ldots,l_k\}$ listing the elements of $L_i$ in some fixed total order $<$ on labels.

\begin{figure}
  \[
  \begin{array}{llll}
    \textit{Types} & T & ::= & \Pia{x}{T}{T'}\ |\ \star\ |\ T\ T'\ |\ \tlam{x}{T}{T'}\ |\ \w{L}{N}{S}\ |\ \{ l_1 , \ldots , l_k \}\
    |\ \eqtm{e}{T}{e'} \\
    \textit{Annotated terms} & M, N & ::= & x\ |\ l\ |\ \tlam{x}{T}{M}\ |\ M\ e\ |\ \wunit\ |\ \ctor{l}{n}{r}\ |\ \wrec{r}{t} \\
    \ &\ &\ & \{ l_1 \mapsto t_1\ ;\ \ldots\ ;\ l_k\mapsto t_k \} \\

    \textit{Expressions} & e & ::= & t\ |\ M\ |\ T
  \end{array}
  \]
\caption{Types and annotated terms of Q}
\label{fig:tp}
\end{figure}


\bibliographystyle{plain}
\bibliography{main}

\end{document}
